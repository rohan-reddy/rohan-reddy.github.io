<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2026-02-06">
<meta name="description" content="Iterating on General Matrix Multiplication in CUDA for optimal performance on NVIDIA GPUs">

<title>Note 001: GEMM Optimization – Rohan Reddy / Notes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../images/logo.svg" rel="icon" type="image/svg+xml">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="floating nav-fixed slimcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../images/logo.svg" alt="" class="navbar-logo light-content">
    <img src="../../images/logo.svg" alt="" class="navbar-logo dark-content">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Rohan Reddy / Notes</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/rohan-reddy-bba12a111/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/rohan-reddy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Note 001: GEMM Optimization</h1>
                  <div>
        <div class="description">
          Iterating on General Matrix Multiplication in CUDA for optimal performance on NVIDIA GPUs
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">CUDA</div>
                <div class="quarto-category">GEMM</div>
                <div class="quarto-category">Linear Algebra</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 6, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a>
  <ul class="collapse">
  <li><a href="#mathematical-definition" id="toc-mathematical-definition" class="nav-link" data-scroll-target="#mathematical-definition">Mathematical definition</a></li>
  <li><a href="#why-gemm" id="toc-why-gemm" class="nav-link" data-scroll-target="#why-gemm">Why GEMM?</a></li>
  <li><a href="#problem-setup" id="toc-problem-setup" class="nav-link" data-scroll-target="#problem-setup">Problem setup</a></li>
  <li><a href="#assumed-background" id="toc-assumed-background" class="nav-link" data-scroll-target="#assumed-background">Assumed background</a></li>
  </ul></li>
  <li><a href="#naive-matrix-multiplication" id="toc-naive-matrix-multiplication" class="nav-link" data-scroll-target="#naive-matrix-multiplication">1. Naive Matrix Multiplication</a>
  <ul class="collapse">
  <li><a href="#annotated-code" id="toc-annotated-code" class="nav-link" data-scroll-target="#annotated-code">Annotated Code</a></li>
  <li><a href="#arithmetic-intensity" id="toc-arithmetic-intensity" class="nav-link" data-scroll-target="#arithmetic-intensity">Arithmetic Intensity</a></li>
  <li><a href="#benchmarks" id="toc-benchmarks" class="nav-link" data-scroll-target="#benchmarks">Benchmarks</a></li>
  </ul></li>
  <li><a href="#tiled-matrix-multiplication" id="toc-tiled-matrix-multiplication" class="nav-link" data-scroll-target="#tiled-matrix-multiplication">2. Tiled Matrix Multiplication</a>
  <ul class="collapse">
  <li><a href="#annotated-code-1" id="toc-annotated-code-1" class="nav-link" data-scroll-target="#annotated-code-1">Annotated Code</a></li>
  <li><a href="#arithmetic-intensity-1" id="toc-arithmetic-intensity-1" class="nav-link" data-scroll-target="#arithmetic-intensity-1">Arithmetic Intensity</a></li>
  <li><a href="#benchmarks-1" id="toc-benchmarks-1" class="nav-link" data-scroll-target="#benchmarks-1">Benchmarks</a></li>
  </ul></li>
  <li><a href="#warp-matrix-multiply-accumulate" id="toc-warp-matrix-multiply-accumulate" class="nav-link" data-scroll-target="#warp-matrix-multiply-accumulate">3. Warp Matrix Multiply Accumulate</a>
  <ul class="collapse">
  <li><a href="#annotated-code-2" id="toc-annotated-code-2" class="nav-link" data-scroll-target="#annotated-code-2">Annotated Code</a></li>
  <li><a href="#arithmetic-intensity-2" id="toc-arithmetic-intensity-2" class="nav-link" data-scroll-target="#arithmetic-intensity-2">Arithmetic Intensity</a></li>
  <li><a href="#benchmarks-2" id="toc-benchmarks-2" class="nav-link" data-scroll-target="#benchmarks-2">Benchmarks</a></li>
  </ul></li>
  <li><a href="#double-buffer" id="toc-double-buffer" class="nav-link" data-scroll-target="#double-buffer">4. Double Buffer</a>
  <ul class="collapse">
  <li><a href="#annotated-code-3" id="toc-annotated-code-3" class="nav-link" data-scroll-target="#annotated-code-3">Annotated Code</a></li>
  <li><a href="#arithmetic-intensity-3" id="toc-arithmetic-intensity-3" class="nav-link" data-scroll-target="#arithmetic-intensity-3">Arithmetic Intensity</a></li>
  <li><a href="#benchmarks-3" id="toc-benchmarks-3" class="nav-link" data-scroll-target="#benchmarks-3">Benchmarks</a></li>
  </ul></li>
  <li><a href="#swizzling" id="toc-swizzling" class="nav-link" data-scroll-target="#swizzling">5. Swizzling</a>
  <ul class="collapse">
  <li><a href="#annotated-code-4" id="toc-annotated-code-4" class="nav-link" data-scroll-target="#annotated-code-4">Annotated Code</a></li>
  <li><a href="#arithmetic-intensity-4" id="toc-arithmetic-intensity-4" class="nav-link" data-scroll-target="#arithmetic-intensity-4">Arithmetic Intensity</a></li>
  <li><a href="#benchmarks-4" id="toc-benchmarks-4" class="nav-link" data-scroll-target="#benchmarks-4">Benchmarks</a></li>
  </ul></li>
  <li><a href="#arbitrary-matrix-dimensions" id="toc-arbitrary-matrix-dimensions" class="nav-link" data-scroll-target="#arbitrary-matrix-dimensions">6. Arbitrary Matrix Dimensions</a>
  <ul class="collapse">
  <li><a href="#annotated-code-5" id="toc-annotated-code-5" class="nav-link" data-scroll-target="#annotated-code-5">Annotated Code</a></li>
  <li><a href="#arithmetic-intensity-5" id="toc-arithmetic-intensity-5" class="nav-link" data-scroll-target="#arithmetic-intensity-5">Arithmetic Intensity</a></li>
  <li><a href="#benchmarks-5" id="toc-benchmarks-5" class="nav-link" data-scroll-target="#benchmarks-5">Benchmarks</a></li>
  </ul></li>
  <li><a href="#final-performance-analysis" id="toc-final-performance-analysis" class="nav-link" data-scroll-target="#final-performance-analysis">Final Performance Analysis</a></li>
  <li><a href="#further-optimizations" id="toc-further-optimizations" class="nav-link" data-scroll-target="#further-optimizations">Further Optimizations</a></li>
  <li><a href="#additional-reading" id="toc-additional-reading" class="nav-link" data-scroll-target="#additional-reading">Additional Reading</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">





<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>General Matrix Multiply, or GEMM, is a linear algebra operation that comprises the majority of computing done by modern deep learning models. In this note, I will explain how we can iteratively optimize GEMM implementations in CUDA until we have almost saturated the capability of modern NVIDIA GPUs.</p>
<section id="mathematical-definition" class="level3">
<h3 class="anchored" data-anchor-id="mathematical-definition">Mathematical definition</h3>
<p>Formally, GEMM is defined as an operation on two input matrices <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, and an accumulation matrix <span class="math inline">\(C\)</span>, scaled by scalars <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span>:</p>
<p><span class="math display">\[
C = \alpha \cdot (A \times B) + \beta \cdot C
\]</span></p>
<p>Where:</p>
<ul>
<li><span class="math inline">\(A\)</span> is an <span class="math inline">\(M \times K\)</span> matrix.</li>
<li><span class="math inline">\(B\)</span> is a <span class="math inline">\(K \times N\)</span> matrix.</li>
<li><span class="math inline">\(C\)</span> is an <span class="math inline">\(M \times N\)</span> matrix.</li>
</ul>
<p><img src="images/01_matrix_dims.svg" class="img-fluid" style="width:80.0%"></p>
<p>In deep learning contexts, <span class="math inline">\(\beta\)</span> is often 0 (overwriting the output) or 1 (accumulating gradients), and <span class="math inline">\(\alpha\)</span> is typically 1.</p>
</section>
<section id="why-gemm" class="level3">
<h3 class="anchored" data-anchor-id="why-gemm">Why GEMM?</h3>
<p>In modern Transformer architectures, GEMM operations account for the vast majority of total Floating Point Operations (FLOPs). This is due to the structure of the Attention operation: <span class="math inline">\(\text{softmax}(\frac{Q \times K^T}{\sqrt{d}}) \times V\)</span>. Aside from the softmax operation, everything else can be represented as GEMM:</p>
<ol type="1">
<li>Calculating the scaled attention scores (<span class="math inline">\(\frac{Q \times K^T}{\sqrt{d}}\)</span>).</li>
<li>Calculating the weighted sum of values (<span class="math inline">\(\text{scores} \times V\)</span>).</li>
</ol>
<p>Since GEMM dominates the runtime, even a small percentage improvement in kernel efficiency can realize massive savings in training and inference costs at scale.</p>
</section>
<section id="problem-setup" class="level3">
<h3 class="anchored" data-anchor-id="problem-setup">Problem setup</h3>
<p>As I iterate on GEMM kernels, I will test them on the General Matrix Multiplication test suite and infrastructure on LeetGPU.com. As per the problem setup there, I will only be using native capabilities of the GPUs, so no libraries like CuTe or cuBLAS. The test suite is hidden, but the known constraints are that each of the matrix dimensions <span class="math inline">\(M\)</span>, <span class="math inline">\(N\)</span>, and <span class="math inline">\(K\)</span> are between 16 and 4096. So the input matrices range from very small (a few hundred elements) to fairly large (16 million elements). The platform tells us the runtime of the kernel on a particular large test case that is unknown to us. The input matrices A and B are given as type half (half-precision floating point number). Lower than usual precision floats are common in AI workloads as they take up less space and allow for higher throughput. For improved accuracy, the computation of the GEMM output will be done using full-precision floats, but the final storage will also be as a half-precision float.</p>
<p>For each kernel, I will explain the algorithm, how it interacts with the GPU architecture and memory hierarchy, and show the full code in CUDA C++. Finally, I will discuss the arithmetic intensity of the kernel and benchmark its performance on the following NVIDIA GPUs: Tesla T4 (2017), Ampere A100-80GB (2020), Hopper H100 (2022), Hopper H200 (2023), and Blackwell B200 (2024).</p>
</section>
<section id="assumed-background" class="level3">
<h3 class="anchored" data-anchor-id="assumed-background">Assumed background</h3>
<p>I will assume the reader understands the basics of the CUDA programming model. If not, I recommend reading the first 6 chapters of Programming Massively Parallel Processors (Kirk &amp; Hwu), an excellent resource and probably the canonical text on this topic.</p>
</section>
</section>
<section id="naive-matrix-multiplication" class="level2">
<h2 class="anchored" data-anchor-id="naive-matrix-multiplication">1. Naive Matrix Multiplication</h2>
<p>In a naive parallel computing model, we can have every thread be solely responsible for computing exactly one output element in the final matrix. Each thread would load the row from A and column from B that it needs for the dot product for that output element.</p>
<p>Hover over the numbered annotations for explanations of key parts.</p>
<section id="annotated-code" class="level3">
<h3 class="anchored" data-anchor-id="annotated-code">Annotated Code</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="annotated-cell-1"><pre class="sourceCode cpp code-annotation-code code-with-copy code-annotated"><code class="sourceCode cpp"><span id="annotated-cell-1-1"><a href="#annotated-cell-1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cuda_fp16.h&gt;</span></span>
<span id="annotated-cell-1-2"><a href="#annotated-cell-1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cuda_runtime.h&gt;</span></span>
<span id="annotated-cell-1-3"><a href="#annotated-cell-1-3" aria-hidden="true" tabindex="-1"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="1">1</button><span id="annotated-cell-1-4" class="code-annotation-target"><a href="#annotated-cell-1-4" aria-hidden="true" tabindex="-1"></a>__global__ <span class="dt">void</span> gemm_naive_kernel<span class="op">(</span><span class="at">const</span> half<span class="op">*</span> A<span class="op">,</span> <span class="at">const</span> half<span class="op">*</span> B<span class="op">,</span> half<span class="op">*</span> C<span class="op">,</span></span>
<span id="annotated-cell-1-5"><a href="#annotated-cell-1-5" aria-hidden="true" tabindex="-1"></a>                                  <span class="dt">int</span> M<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> K<span class="op">,</span> </span>
<span id="annotated-cell-1-6"><a href="#annotated-cell-1-6" aria-hidden="true" tabindex="-1"></a>                                  <span class="dt">float</span> alpha<span class="op">,</span> <span class="dt">float</span> beta<span class="op">)</span> <span class="op">{</span> </span>
<span id="annotated-cell-1-7"><a href="#annotated-cell-1-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="annotated-cell-1-8"><a href="#annotated-cell-1-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calculate global row and column indices for this thread</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="2">2</button><span id="annotated-cell-1-9" class="code-annotation-target"><a href="#annotated-cell-1-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> col <span class="op">=</span> blockIdx<span class="op">.</span>x <span class="op">*</span> blockDim<span class="op">.</span>x <span class="op">+</span> threadIdx<span class="op">.</span>x<span class="op">;</span></span>
<span id="annotated-cell-1-10"><a href="#annotated-cell-1-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> row <span class="op">=</span> blockIdx<span class="op">.</span>y <span class="op">*</span> blockDim<span class="op">.</span>y <span class="op">+</span> threadIdx<span class="op">.</span>y<span class="op">;</span></span>
<span id="annotated-cell-1-11"><a href="#annotated-cell-1-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="annotated-cell-1-12"><a href="#annotated-cell-1-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Boundary check: ensure we don't access memory outside the matrix</span></span>
<span id="annotated-cell-1-13"><a href="#annotated-cell-1-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>row <span class="op">&lt;</span> M <span class="op">&amp;&amp;</span> col <span class="op">&lt;</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-1-14"><a href="#annotated-cell-1-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span> val <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="annotated-cell-1-15"><a href="#annotated-cell-1-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="annotated-cell-1-16"><a href="#annotated-cell-1-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// The K-loop: Perform the dot product</span></span>
<span id="annotated-cell-1-17"><a href="#annotated-cell-1-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> K<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-1-18"><a href="#annotated-cell-1-18" aria-hidden="true" tabindex="-1"></a>            val <span class="op">+=</span> __half2float<span class="op">(</span>A<span class="op">[</span>row <span class="op">*</span> K <span class="op">+</span> i<span class="op">])</span> <span class="op">*</span> __half2float<span class="op">(</span>B<span class="op">[</span>i <span class="op">*</span> N <span class="op">+</span> col<span class="op">]);</span></span>
<span id="annotated-cell-1-19"><a href="#annotated-cell-1-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-1-20"><a href="#annotated-cell-1-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="annotated-cell-1-21"><a href="#annotated-cell-1-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Write result back to C</span></span>
<span id="annotated-cell-1-22"><a href="#annotated-cell-1-22" aria-hidden="true" tabindex="-1"></a>        val <span class="op">=</span> alpha <span class="op">*</span> val <span class="op">+</span> beta <span class="op">*</span> __half2float<span class="op">(</span>C<span class="op">[</span>row <span class="op">*</span> N <span class="op">+</span> col<span class="op">]);</span></span>
<span id="annotated-cell-1-23"><a href="#annotated-cell-1-23" aria-hidden="true" tabindex="-1"></a>        C<span class="op">[</span>row <span class="op">*</span> N <span class="op">+</span> col<span class="op">]</span> <span class="op">=</span> __float2half<span class="op">(</span>val<span class="op">);</span></span>
<span id="annotated-cell-1-24"><a href="#annotated-cell-1-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-1-25"><a href="#annotated-cell-1-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="annotated-cell-1-26"><a href="#annotated-cell-1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-1-27"><a href="#annotated-cell-1-27" aria-hidden="true" tabindex="-1"></a><span class="co">// Wrapper function to be called from Host</span></span>
<span id="annotated-cell-1-28"><a href="#annotated-cell-1-28" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> <span class="st">"C"</span> <span class="dt">void</span> solve<span class="op">(</span><span class="at">const</span> half<span class="op">*</span> A<span class="op">,</span> <span class="at">const</span> half<span class="op">*</span> B<span class="op">,</span> half<span class="op">*</span> C<span class="op">,</span> <span class="dt">int</span> M<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> K<span class="op">,</span> <span class="dt">float</span> alpha<span class="op">,</span> <span class="dt">float</span> beta<span class="op">)</span> <span class="op">{</span> </span>
<span id="annotated-cell-1-29"><a href="#annotated-cell-1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-1-30"><a href="#annotated-cell-1-30" aria-hidden="true" tabindex="-1"></a>    dim3 block<span class="op">(</span><span class="dv">16</span><span class="op">,</span> <span class="dv">16</span><span class="op">);</span></span>
<span id="annotated-cell-1-31"><a href="#annotated-cell-1-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Grid calculation: ensures we cover the entire matrix (ceiling division)</span></span>
<span id="annotated-cell-1-32"><a href="#annotated-cell-1-32" aria-hidden="true" tabindex="-1"></a>    dim3 grid<span class="op">(</span></span>
<span id="annotated-cell-1-33"><a href="#annotated-cell-1-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">(</span>N <span class="op">+</span> <span class="dv">15</span><span class="op">)</span> <span class="op">/</span> <span class="dv">16</span><span class="op">,</span></span>
<span id="annotated-cell-1-34"><a href="#annotated-cell-1-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">(</span>M <span class="op">+</span> <span class="dv">15</span><span class="op">)</span> <span class="op">/</span> <span class="dv">16</span></span>
<span id="annotated-cell-1-35"><a href="#annotated-cell-1-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="annotated-cell-1-36"><a href="#annotated-cell-1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-1-37"><a href="#annotated-cell-1-37" aria-hidden="true" tabindex="-1"></a>    gemm_naive_kernel<span class="op">&lt;&lt;&lt;</span>grid<span class="op">,</span> block<span class="op">&gt;&gt;&gt;(</span>A<span class="op">,</span> B<span class="op">,</span> C<span class="op">,</span> M<span class="op">,</span> N<span class="op">,</span> K<span class="op">,</span> alpha<span class="op">,</span> beta<span class="op">);</span></span>
<span id="annotated-cell-1-38"><a href="#annotated-cell-1-38" aria-hidden="true" tabindex="-1"></a>    cudaDeviceSynchronize<span class="op">();</span></span>
<span id="annotated-cell-1-39"><a href="#annotated-cell-1-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-1" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="4" data-code-annotation="1"><strong>half vs.&nbsp;float</strong>: We use <code>half</code> precision (FP16) for storage but perform accumulation in <code>float</code> (FP32). This is so that we can move data faster from global memory (only 2 bytes per element rather than 4), but during the accumulation computation, we don’t lose small updates due to the smaller mantissa in FP16. (For example, imagine adding 0.01 to a running sum of 1000: if our mantissa is small enough, we may significantly alter or even omit some updates.)</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="9,18" data-code-annotation="2"><strong>The Bottleneck</strong>: This line is the performance killer. For every single pixel in C, we are fetching the entire row of A and column of B from Global Memory (DRAM).</span>
</dd>
</dl>
</section>
<section id="arithmetic-intensity" class="level3">
<h3 class="anchored" data-anchor-id="arithmetic-intensity">Arithmetic Intensity</h3>
<p>For each output element of C, we load K elements of A and K elements of B in order to compute a dot product. For each pair of elements in the dot product, we multiply them together and then add the result to the running sum. Therefore, for every 2 halves we load from global memory (a total of 4 bytes), we perform 2 floating point operations. So our computational intensity is 2 FLOPs divided by 4 bytes, or 0.5 FLOP/B.</p>
</section>
<section id="benchmarks" class="level3">
<h3 class="anchored" data-anchor-id="benchmarks">Benchmarks</h3>
<p>Below, we can see the runtime of our kernel on the same test suite for each GPU. We can also compare the arithmetic intensity of the kernel to the ridge point of each GPU (the arithmetic intensity at which kernels switch from memory-bound to compute-bound). This kernel is highly memory-bound on every GPU. Our first course of action to improve the performance of our kernel should be to rethink our memory access pattern.</p>
<table class="table">
<caption>If our arithmetic intensity is below the Ridge Point, kernels are memory bound. Above the Ridge Point, kernels are compute bound.</caption>
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">GPU Model</th>
<th style="text-align: left;">Memory Bandwidth</th>
<th style="text-align: left;">Peak FP16 Compute</th>
<th style="text-align: left;">Ridge Point (FLOP/Byte)</th>
<th style="text-align: left;">Runtime (ms)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>NVIDIA T4</strong></td>
<td style="text-align: left;">320 GB/s</td>
<td style="text-align: left;">65 TFLOPS</td>
<td style="text-align: left;">203</td>
<td style="text-align: left;">8.49</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>NVIDIA A100 (80GB)</strong></td>
<td style="text-align: left;">2,039 GB/s</td>
<td style="text-align: left;">312 TFLOPS</td>
<td style="text-align: left;">153</td>
<td style="text-align: left;">1.03</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>NVIDIA H100 (SXM)</strong></td>
<td style="text-align: left;">3,350 GB/s</td>
<td style="text-align: left;">989 TFLOPS</td>
<td style="text-align: left;">295</td>
<td style="text-align: left;">0.54</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>NVIDIA H200 (SXM)</strong></td>
<td style="text-align: left;">4,800 GB/s</td>
<td style="text-align: left;">989 TFLOPS</td>
<td style="text-align: left;">206</td>
<td style="text-align: left;">0.53</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>NVIDIA B200</strong></td>
<td style="text-align: left;">8,000 GB/s</td>
<td style="text-align: left;">2,500 TFLOPS</td>
<td style="text-align: left;">312</td>
<td style="text-align: left;">0.50</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="tiled-matrix-multiplication" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="tiled-matrix-multiplication">2. Tiled Matrix Multiplication</h2>
<p>The main issue with our memory access pattern above was that we are redundantly accessing each row N times and each column M times. Why? Recall that the output C is an M x N matrix. Therefore for <span class="math inline">\(C_{1,1}\)</span>, we need to compute the dot product of row 1 of A with column 1 of B; then for <span class="math inline">\(C_{2,1}\)</span>, we need to compute the dot product of row 2 of A with column 1 of B again. So we retrieve column 1 of B from global memory a total of M times. Similarly, row 1 of A is retrieved from global memory a total of N times, since we access it once for each element in row 1 of the output.</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="images/02_a100_memory.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption class="margin-caption">Memory hierarchy of an A100-40GB</figcaption>
</figure>
</div>
<p>When we execute our kernel, we pass it a grid configuration that defines a total number of blocks and how we can index them, and a total number of threads per block and how we can index them. Multiple blocks will be assigned to a single Streaming Multiprocessor (SM) of the GPU at any given time. So all threads in an individual block have access to the same Shared Memory and L1 Cache on their resident Streaming Multiprocessor during execution. We can take advantage of this local memory to reduce our global memory accesses. This pattern is known as locality.</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="images/03_tiled_mm.png" class="img-fluid figure-img" style="width:95.0%"></p>
<figcaption class="margin-caption">Visualization of tiled matrix multiplication</figcaption>
</figure>
</div>
<p>In tiled matrix multiplication, we choose a tile size which will comprise the total threads in a single block. We will choose 16 x 16 as our tile size so that we have a nice total of 256 threads per block. (32 x 32 would also work, but beyond that we need to be cognizant of hardware restrictions on the maximum number of threads per block). We then loop over a wide row in A and a wide column in B, one tile at a time, as shown above. During each loop iteration, we have a single tile in A and tile in B to process. Each thread is responsible for loading in one element each from A and B to the block’s shared memory. Then in an inner loop, we compute the product of those tiles and add it to the running sum for the output tile. By the end of the outer loop, we have loaded in and processed all elements required for the final value of elements in the 16 x 16 output tile, and so we can write to global memory.</p>
<p>One additional optimization we introduce here is thread coarsening. This means that each thread is tasked with doing more work independently. The advantage of this approach is that if our grid ends up launching more total blocks than the hardware can assign to its SMs, then the blocks will inevitably be queued for assignment and execution. In that case, the blocks will be executed serially anyway, so we may as well have threads do more work in the first place and reduce some redundant data loading and synchronization overhead. However, we must be careful not to coarsen so much that we are no longer taking full advantage of the hardware. For our tiled matrix multiplication kernel, it can make sense for large matrices to have some coarsening. This is because although we have reduced redundancy in global memory accesses, we still will access the same “wide row” in A in two different blocks for two side-by-side output tiles in C. We can experiment with having a thread coarsening factor of 2, which means each block will process two output tiles in C rather than one.</p>
<section id="annotated-code-1" class="level3">
<h3 class="anchored" data-anchor-id="annotated-code-1">Annotated Code</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="annotated-cell-2"><pre class="sourceCode cpp code-annotation-code code-with-copy code-annotated"><code class="sourceCode cpp"><span id="annotated-cell-2-1"><a href="#annotated-cell-2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cuda_fp16.h&gt;</span></span>
<span id="annotated-cell-2-2"><a href="#annotated-cell-2-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cuda_runtime.h&gt;</span></span>
<span id="annotated-cell-2-3"><a href="#annotated-cell-2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-2-4"><a href="#annotated-cell-2-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define TILE_WIDTH </span><span class="dv">16</span></span>
<span id="annotated-cell-2-5"><a href="#annotated-cell-2-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define COARSE_FACTOR </span><span class="dv">2</span></span>
<span id="annotated-cell-2-6"><a href="#annotated-cell-2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-2-7"><a href="#annotated-cell-2-7" aria-hidden="true" tabindex="-1"></a>__global__ <span class="dt">void</span> gemm_tiled_kernel<span class="op">(</span><span class="at">const</span> half<span class="op">*</span> A<span class="op">,</span> <span class="at">const</span> half<span class="op">*</span> B<span class="op">,</span> half<span class="op">*</span> C<span class="op">,</span> <span class="dt">int</span> M<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> K<span class="op">,</span> <span class="dt">float</span> alpha<span class="op">,</span> <span class="dt">float</span> beta<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-2-8"><a href="#annotated-cell-2-8" aria-hidden="true" tabindex="-1"></a>    </span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="1">1</button><span id="annotated-cell-2-9" class="code-annotation-target"><a href="#annotated-cell-2-9" aria-hidden="true" tabindex="-1"></a>    __shared__ <span class="dt">float</span> As<span class="op">[</span>TILE_WIDTH<span class="op">][</span>TILE_WIDTH<span class="op">];</span></span>
<span id="annotated-cell-2-10"><a href="#annotated-cell-2-10" aria-hidden="true" tabindex="-1"></a>    __shared__ <span class="dt">float</span> Bs<span class="op">[</span>TILE_WIDTH<span class="op">][</span>TILE_WIDTH<span class="op">];</span></span>
<span id="annotated-cell-2-11"><a href="#annotated-cell-2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-2-12"><a href="#annotated-cell-2-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> row <span class="op">=</span> TILE_WIDTH <span class="op">*</span> blockIdx<span class="op">.</span>y <span class="op">+</span> threadIdx<span class="op">.</span>y<span class="op">;</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="2">2</button><span id="annotated-cell-2-13" class="code-annotation-target"><a href="#annotated-cell-2-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> colStart <span class="op">=</span> COARSE_FACTOR <span class="op">*</span> TILE_WIDTH <span class="op">*</span> blockIdx<span class="op">.</span>x <span class="op">+</span> threadIdx<span class="op">.</span>x<span class="op">;</span></span>
<span id="annotated-cell-2-14"><a href="#annotated-cell-2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-2-15"><a href="#annotated-cell-2-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> sum<span class="op">[</span>COARSE_FACTOR<span class="op">];</span> </span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="3">3</button><span id="annotated-cell-2-16" class="code-annotation-target"><a href="#annotated-cell-2-16" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-2-17"><a href="#annotated-cell-2-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> c <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> c <span class="op">&lt;</span> COARSE_FACTOR<span class="op">;</span> c<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-2-18"><a href="#annotated-cell-2-18" aria-hidden="true" tabindex="-1"></a>        sum<span class="op">[</span>c<span class="op">]</span> <span class="op">=</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="annotated-cell-2-19"><a href="#annotated-cell-2-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-2-20"><a href="#annotated-cell-2-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-2-21"><a href="#annotated-cell-2-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Loop over the K-dimension (shared dimension)</span></span>
<span id="annotated-cell-2-22"><a href="#annotated-cell-2-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> phase <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> phase <span class="op">&lt;</span> <span class="op">(</span>K <span class="op">+</span> TILE_WIDTH <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> TILE_WIDTH<span class="op">;</span> phase<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-2-23"><a href="#annotated-cell-2-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="annotated-cell-2-24"><a href="#annotated-cell-2-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// --- Load A ---</span></span>
<span id="annotated-cell-2-25"><a href="#annotated-cell-2-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// A is (M x K). </span></span>
<span id="annotated-cell-2-26"><a href="#annotated-cell-2-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Row comes from global 'row'. </span></span>
<span id="annotated-cell-2-27"><a href="#annotated-cell-2-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Col comes from 'phase' and 'threadIdx.x'.</span></span>
<span id="annotated-cell-2-28"><a href="#annotated-cell-2-28" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a_col <span class="op">=</span> phase <span class="op">*</span> TILE_WIDTH <span class="op">+</span> threadIdx<span class="op">.</span>x<span class="op">;</span></span>
<span id="annotated-cell-2-29"><a href="#annotated-cell-2-29" aria-hidden="true" tabindex="-1"></a>        As<span class="op">[</span>threadIdx<span class="op">.</span>y<span class="op">][</span>threadIdx<span class="op">.</span>x<span class="op">]</span> <span class="op">=</span> </span>
<span id="annotated-cell-2-30"><a href="#annotated-cell-2-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span>row <span class="op">&lt;</span> M <span class="op">&amp;&amp;</span> a_col <span class="op">&lt;</span> K<span class="op">)</span> <span class="op">?</span> </span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="4">4</button><span id="annotated-cell-2-31" class="code-annotation-target"><a href="#annotated-cell-2-31" aria-hidden="true" tabindex="-1"></a>            __half2float<span class="op">(</span>A<span class="op">[</span>row <span class="op">*</span> K <span class="op">+</span> a_col<span class="op">])</span> <span class="op">:</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="annotated-cell-2-32"><a href="#annotated-cell-2-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-2-33"><a href="#annotated-cell-2-33" aria-hidden="true" tabindex="-1"></a>        <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-2-34"><a href="#annotated-cell-2-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> c <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> c <span class="op">&lt;</span> COARSE_FACTOR<span class="op">;</span> c<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-2-35"><a href="#annotated-cell-2-35" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> col <span class="op">=</span> colStart <span class="op">+</span> c <span class="op">*</span> TILE_WIDTH<span class="op">;</span></span>
<span id="annotated-cell-2-36"><a href="#annotated-cell-2-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-2-37"><a href="#annotated-cell-2-37" aria-hidden="true" tabindex="-1"></a>            <span class="co">// --- Load B ---</span></span>
<span id="annotated-cell-2-38"><a href="#annotated-cell-2-38" aria-hidden="true" tabindex="-1"></a>            <span class="co">// B is (K x N). </span></span>
<span id="annotated-cell-2-39"><a href="#annotated-cell-2-39" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Row comes from 'phase' and 'threadIdx.y'. </span></span>
<span id="annotated-cell-2-40"><a href="#annotated-cell-2-40" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Col comes from global 'col'.</span></span>
<span id="annotated-cell-2-41"><a href="#annotated-cell-2-41" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> b_row <span class="op">=</span> phase <span class="op">*</span> TILE_WIDTH <span class="op">+</span> threadIdx<span class="op">.</span>y<span class="op">;</span></span>
<span id="annotated-cell-2-42"><a href="#annotated-cell-2-42" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="annotated-cell-2-43"><a href="#annotated-cell-2-43" aria-hidden="true" tabindex="-1"></a>            Bs<span class="op">[</span>threadIdx<span class="op">.</span>y<span class="op">][</span>threadIdx<span class="op">.</span>x<span class="op">]</span> <span class="op">=</span> </span>
<span id="annotated-cell-2-44"><a href="#annotated-cell-2-44" aria-hidden="true" tabindex="-1"></a>                <span class="op">(</span>b_row <span class="op">&lt;</span> K <span class="op">&amp;&amp;</span> col <span class="op">&lt;</span> N<span class="op">)</span> <span class="op">?</span></span>
<span id="annotated-cell-2-45"><a href="#annotated-cell-2-45" aria-hidden="true" tabindex="-1"></a>                __half2float<span class="op">(</span>B<span class="op">[</span>b_row <span class="op">*</span> N <span class="op">+</span> col<span class="op">])</span> <span class="op">:</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">;</span> </span>
<span id="annotated-cell-2-46"><a href="#annotated-cell-2-46" aria-hidden="true" tabindex="-1"></a>            </span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="5">5</button><span id="annotated-cell-2-47" class="code-annotation-target"><a href="#annotated-cell-2-47" aria-hidden="true" tabindex="-1"></a>            __syncthreads<span class="op">();</span></span>
<span id="annotated-cell-2-48"><a href="#annotated-cell-2-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-2-49"><a href="#annotated-cell-2-49" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> TILE_WIDTH<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-2-50"><a href="#annotated-cell-2-50" aria-hidden="true" tabindex="-1"></a>                sum<span class="op">[</span>c<span class="op">]</span> <span class="op">+=</span> As<span class="op">[</span>threadIdx<span class="op">.</span>y<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> Bs<span class="op">[</span>j<span class="op">][</span>threadIdx<span class="op">.</span>x<span class="op">];</span></span>
<span id="annotated-cell-2-51"><a href="#annotated-cell-2-51" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="annotated-cell-2-52"><a href="#annotated-cell-2-52" aria-hidden="true" tabindex="-1"></a>            __syncthreads<span class="op">();</span></span>
<span id="annotated-cell-2-53"><a href="#annotated-cell-2-53" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-2-54"><a href="#annotated-cell-2-54" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-2-55"><a href="#annotated-cell-2-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-2-56"><a href="#annotated-cell-2-56" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-2-57"><a href="#annotated-cell-2-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> c <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> c <span class="op">&lt;</span> COARSE_FACTOR<span class="op">;</span> c<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-2-58"><a href="#annotated-cell-2-58" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> col <span class="op">=</span> colStart <span class="op">+</span> c <span class="op">*</span> TILE_WIDTH<span class="op">;</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="6">6</button><span id="annotated-cell-2-59" class="code-annotation-target"><a href="#annotated-cell-2-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>row <span class="op">&lt;</span> M <span class="op">&amp;&amp;</span> col <span class="op">&lt;</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-2-60"><a href="#annotated-cell-2-60" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> idx <span class="op">=</span> row <span class="op">*</span> N <span class="op">+</span> col<span class="op">;</span> <span class="co">// C is (M x N), stride is N</span></span>
<span id="annotated-cell-2-61"><a href="#annotated-cell-2-61" aria-hidden="true" tabindex="-1"></a>            <span class="dt">float</span> initial_val <span class="op">=</span> __half2float<span class="op">(</span>C<span class="op">[</span>idx<span class="op">]);</span></span>
<span id="annotated-cell-2-62"><a href="#annotated-cell-2-62" aria-hidden="true" tabindex="-1"></a>            C<span class="op">[</span>idx<span class="op">]</span> <span class="op">=</span> __float2half<span class="op">(</span>alpha <span class="op">*</span> sum<span class="op">[</span>c<span class="op">]</span> <span class="op">+</span> beta <span class="op">*</span> initial_val<span class="op">);</span></span>
<span id="annotated-cell-2-63"><a href="#annotated-cell-2-63" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-2-64"><a href="#annotated-cell-2-64" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-2-65"><a href="#annotated-cell-2-65" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="annotated-cell-2-66"><a href="#annotated-cell-2-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-2-67"><a href="#annotated-cell-2-67" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> <span class="st">"C"</span> <span class="dt">void</span> solve<span class="op">(</span><span class="at">const</span> half<span class="op">*</span> A<span class="op">,</span> <span class="at">const</span> half<span class="op">*</span> B<span class="op">,</span> half<span class="op">*</span> C<span class="op">,</span> <span class="dt">int</span> M<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> K<span class="op">,</span> <span class="dt">float</span> alpha<span class="op">,</span></span>
<span id="annotated-cell-2-68"><a href="#annotated-cell-2-68" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">float</span> beta<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-2-69"><a href="#annotated-cell-2-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-2-70"><a href="#annotated-cell-2-70" aria-hidden="true" tabindex="-1"></a>    dim3 block<span class="op">(</span>TILE_WIDTH<span class="op">,</span> TILE_WIDTH<span class="op">);</span></span>
<span id="annotated-cell-2-71"><a href="#annotated-cell-2-71" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="annotated-cell-2-72"><a href="#annotated-cell-2-72" aria-hidden="true" tabindex="-1"></a>    dim3 grid<span class="op">(</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="7">7</button><span id="annotated-cell-2-73" class="code-annotation-target"><a href="#annotated-cell-2-73" aria-hidden="true" tabindex="-1"></a>        <span class="op">(</span>N <span class="op">+</span> <span class="op">(</span>TILE_WIDTH <span class="op">*</span> COARSE_FACTOR<span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span>TILE_WIDTH <span class="op">*</span> COARSE_FACTOR<span class="op">),</span></span>
<span id="annotated-cell-2-74"><a href="#annotated-cell-2-74" aria-hidden="true" tabindex="-1"></a>        <span class="op">(</span>M <span class="op">+</span> TILE_WIDTH <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> TILE_WIDTH</span>
<span id="annotated-cell-2-75"><a href="#annotated-cell-2-75" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span> </span>
<span id="annotated-cell-2-76"><a href="#annotated-cell-2-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-2-77"><a href="#annotated-cell-2-77" aria-hidden="true" tabindex="-1"></a>    gemm_tiled_kernel<span class="op">&lt;&lt;&lt;</span>grid<span class="op">,</span> block<span class="op">&gt;&gt;&gt;(</span>A<span class="op">,</span> B<span class="op">,</span> C<span class="op">,</span> M<span class="op">,</span> N<span class="op">,</span> K<span class="op">,</span> alpha<span class="op">,</span> beta<span class="op">);</span></span>
<span id="annotated-cell-2-78"><a href="#annotated-cell-2-78" aria-hidden="true" tabindex="-1"></a>    cudaDeviceSynchronize<span class="op">();</span></span>
<span id="annotated-cell-2-79"><a href="#annotated-cell-2-79" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-2" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="9" data-code-annotation="1"><strong>Shared memory</strong>: We declare our block shared memory. One can also dynamically pass the total size of block shared memory to the kernel at runtime if desired. In our case, we have a predetermined tile width. Note that we need to be cognizant of the total shared memory available on an SM. Our oldest GPU, the T4, has 64 KB of shared memory per SM. Here, we have two arrays of 16 x 16 floats each, so 512 total floats, so 4 KB. We’re well within the limits. I went ahead and converted the halves to floats at this stage since we’re so far within shared memory limits, but to save on half of the shared memory allocation, we could declare the shared memory arrays as type half and convert them at compute time.</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="13" data-code-annotation="2"><strong>Coarsening</strong>: We set COARSE_FACTOR to 2, so each thread is going to load in 2 elements each from A and B, and compute 2 output elements in C. We are loading in two horizontal tiles at a time per block, so we need to apply our coarsening factor to our column computation.</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="16" data-code-annotation="3"><strong>Loop unrolling</strong>: <code>#pragma unroll</code> is a directive that asks the compiler to try to unroll the loop fully, especially if the total number of iterations is known at compile time. To unroll a loop means to duplicate the code in the loop body rather than perform a condition check and a jump back to the start of the loop body. This allows us to avoid the execution speed cost of checking the loop condition, with the tradeoff of increasing code size. From here on out, we will typically unroll any loop with a constant number of iterations.</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="31" data-code-annotation="4"><strong>Boundary checks</strong>: Our tiles are a fixed size. So if our matrix dimensions are not all multiples of 16, we will have some tiles that aren’t fully contained within the input matrices and try to access out-of-bound indices. We can simply set these values to 0 in shared memory so that they accumulate to 0 and don’t impact the result.</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="47" data-code-annotation="5"><strong><code>__syncthreads()</code></strong>: This instruction forces each thread in the block to halt here and wait until every other thread in the block reaches this point. This first syncthreads command is known as a Read-After-Write hazard, and the one after it is known as a Write-After-Read hazard. In the first case, individual threads rely on reading shared memory that other threads in their block are writing to. In the second case, if we don’t have a barrier, then some threads risk proceeding to the next loop iteration and modifying shared memory before other threads have read it for their computation on the previous iteration.</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="6">6</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="59" data-code-annotation="6"><strong>Another boundary check</strong>: When we write to C, we again need to check that we are within bounds, since some tiles may not be fully contained at the end of the grid.</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="7">7</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="73" data-code-annotation="7"><strong>Grid calculation with coarsening</strong>: We adjust our grid calculation to account for the coarsening in the horizontal dimension; this impacts the total number of blocks we need horizontally.</span>
</dd>
</dl>
</section>
<section id="arithmetic-intensity-1" class="level3">
<h3 class="anchored" data-anchor-id="arithmetic-intensity-1">Arithmetic Intensity</h3>
<p>Now that we are reusing some global memory, our arithmetic intensity is higher. The coarsening factor doesn’t impact the arithmetic intensity, so let’s ignore it for the calculation. A single thread is computing a single output element in C, but it doesn’t have to load every element in the vectors of A and B that are used for that dot product. It only has to load one element of A and one element of B per tile, and then it benefits from the other 15 elements it needs from each matrix for each tile that were loaded by other threads. Therefore we reduced the number of global memory accesses by a factor of 16. But we are performing the same number of floating point operations, so our arithmetic intensity is simply 16 times higher than that of the naive kernel. Hence the arithmetic intensity of this kernel is 8 FLOPs/B.</p>
</section>
<section id="benchmarks-1" class="level3">
<h3 class="anchored" data-anchor-id="benchmarks-1">Benchmarks</h3>
<p>The runtime improved from our increase in arithmetic intensity. The kernel is still memory-bound though on every GPU. In the next section, we will address this by taking advantage of a fundamental hardware capability that happens to available in every GPU in our test set.</p>
<table class="table">
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">GPU Model</th>
<th style="text-align: left;">Memory Bandwidth</th>
<th style="text-align: left;">Peak FP16 Compute</th>
<th style="text-align: left;">Ridge Point (FLOP/Byte)</th>
<th style="text-align: left;">Runtime (ms)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>NVIDIA T4</strong></td>
<td style="text-align: left;">320 GB/s</td>
<td style="text-align: left;">65 TFLOPS</td>
<td style="text-align: left;">203</td>
<td style="text-align: left;">6.73</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>NVIDIA A100 (80GB)</strong></td>
<td style="text-align: left;">2,039 GB/s</td>
<td style="text-align: left;">312 TFLOPS</td>
<td style="text-align: left;">153</td>
<td style="text-align: left;">0.72</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>NVIDIA H100 (SXM)</strong></td>
<td style="text-align: left;">3,350 GB/s</td>
<td style="text-align: left;">989 TFLOPS</td>
<td style="text-align: left;">295</td>
<td style="text-align: left;">0.37</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>NVIDIA H200 (SXM)</strong></td>
<td style="text-align: left;">4,800 GB/s</td>
<td style="text-align: left;">989 TFLOPS</td>
<td style="text-align: left;">206</td>
<td style="text-align: left;">0.36</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>NVIDIA B200</strong></td>
<td style="text-align: left;">8,000 GB/s</td>
<td style="text-align: left;">2,500 TFLOPS</td>
<td style="text-align: left;">312</td>
<td style="text-align: left;">0.33</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="warp-matrix-multiply-accumulate" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="warp-matrix-multiply-accumulate">3. Warp Matrix Multiply Accumulate</h2>
<p>Every GPU in our test suite is modern enough to be equipped with Tensor Cores: programmable matrix-multiply-and-accumulate units that deliver massively higher throughput. Each SM has many of these Tensor Cores. An individual Tensor Core performs the operation <span class="math inline">\(D = A \times B + C\)</span>, where every matrix in the operation has size 4x4. We call the shape of this operation 4x4x4. Additionally, Tensor Cores natively handle mixed-precision: the input matrices A and B are expected to be half-precision (FP16), while the accumulators C and D can be either FP16 or FP32.</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="images/04_tensor_core.png" class="img-fluid figure-img" style="width:90.0%"></p>
<figcaption class="margin-caption">Tensor Core performing a 4x4x4 matrix multiply and accumulate operation</figcaption>
</figure>
</div>
<p>This capability is exposed to us as the Warp Matrix Multiply Accumulate API (WMMA). During program execution, a full warp of execution will use multiple Tensor Cores at a time in order to process a 16x16x16 MMA operation.</p>
<p>There are several advantages of using WMMA rather than manually programming the matrix multiply and accumulate operation like we did in previous kernels.</p>
<ol type="1">
<li>Single instruction: As opposed to issuing separate multiplication and addition instructions manually, the warp scheduler issues a single instruction to the Tensor Core hardware, which proceeds to take over the rest of the operation. GPUs have a limited rate at which they can feed instructions to the execution units, so this allows us to issue memory requests much faster and get closer to saturating the memory bus.</li>
<li>Matrix loading: The <code>load_matrix_sync</code> instruction in WMMA is optimized to use 128-bit global loads. So it retrieves 16 bytes (8 halves) in a single transaction. Meanwhile, when we manually load half data, we are loading 2 bytes at a time unless we specify otherwise (discussed in a subsequent section, when we explicitly issue vectorized loads).</li>
<li>Dedicated registers: Tensor Cores have dedicated register file data paths and accumulation buffers, laid out to maximize efficiency. We don’t have to deal with register pressure (when we risk allocating too many local variables that live in registers, which can spill over to slower memory stores in we exceed the register capacity) or bank conflicts (discussed in a subsequent section). We don’t have to manage all of this ourselves as it’s already fully optimized when we use the Tensor Cores.</li>
</ol>
<p>One disadvantage of WMMA is that we are locked into the 16x16x16 operation shape. Later on, we’ll adapt our kernel to handle any arbitrary matrix sizes. For now, we’ll have our host code decide whether to use our WMMA kernel based on the input matrix sizes.</p>
<section id="annotated-code-2" class="level3">
<h3 class="anchored" data-anchor-id="annotated-code-2">Annotated Code</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="annotated-cell-3"><pre class="sourceCode cpp code-annotation-code code-with-copy code-annotated"><code class="sourceCode cpp"><span id="annotated-cell-3-1"><a href="#annotated-cell-3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cuda_runtime.h&gt;</span></span>
<span id="annotated-cell-3-2"><a href="#annotated-cell-3-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cuda_fp16.h&gt;</span></span>
<span id="annotated-cell-3-3"><a href="#annotated-cell-3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-4"><a href="#annotated-cell-3-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;mma.h&gt;</span></span>
<span id="annotated-cell-3-5"><a href="#annotated-cell-3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-6"><a href="#annotated-cell-3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> nvcuda<span class="op">;</span></span>
<span id="annotated-cell-3-7"><a href="#annotated-cell-3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-8"><a href="#annotated-cell-3-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#define WARP_SIZE </span><span class="dv">32</span></span>
<span id="annotated-cell-3-9"><a href="#annotated-cell-3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-10"><a href="#annotated-cell-3-10" aria-hidden="true" tabindex="-1"></a>__global__ <span class="dt">void</span> gemm_wmma<span class="op">(</span><span class="at">const</span> half<span class="op">*</span> A<span class="op">,</span> <span class="at">const</span> half<span class="op">*</span> B<span class="op">,</span> half<span class="op">*</span> C<span class="op">,</span> <span class="dt">int</span> M<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> K<span class="op">,</span> <span class="dt">float</span> alpha<span class="op">,</span> <span class="dt">float</span> beta<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-3-11"><a href="#annotated-cell-3-11" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="annotated-cell-3-12"><a href="#annotated-cell-3-12" aria-hidden="true" tabindex="-1"></a>   <span class="co">// Leading dimensions for Row-Major matrices</span></span>
<span id="annotated-cell-3-13"><a href="#annotated-cell-3-13" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span> lead_dim_A <span class="op">=</span> K<span class="op">;</span> <span class="co">// A: M x K. Stride between rows is K</span></span>
<span id="annotated-cell-3-14"><a href="#annotated-cell-3-14" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span> lead_dim_B <span class="op">=</span> N<span class="op">;</span> <span class="co">// B: K x N. Stride between rows is N</span></span>
<span id="annotated-cell-3-15"><a href="#annotated-cell-3-15" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span> lead_dim_C <span class="op">=</span> N<span class="op">;</span> <span class="co">// C: M x N. Stride between rows is N</span></span>
<span id="annotated-cell-3-16"><a href="#annotated-cell-3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-17"><a href="#annotated-cell-3-17" aria-hidden="true" tabindex="-1"></a>   <span class="co">// 2D grid tiling. We will have multiple warps worth of threads in the x dimension.</span></span>
<span id="annotated-cell-3-18"><a href="#annotated-cell-3-18" aria-hidden="true" tabindex="-1"></a>   <span class="co">// Hence warp_col is divided by warp size. </span></span>
<span id="annotated-cell-3-19"><a href="#annotated-cell-3-19" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span> warp_row <span class="op">=</span> blockDim<span class="op">.</span>y <span class="op">*</span> blockIdx<span class="op">.</span>y <span class="op">+</span> threadIdx<span class="op">.</span>y<span class="op">;</span></span>
<span id="annotated-cell-3-20"><a href="#annotated-cell-3-20" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span> warp_col <span class="op">=</span> <span class="op">(</span>blockDim<span class="op">.</span>x <span class="op">*</span> blockIdx<span class="op">.</span>x <span class="op">+</span> threadIdx<span class="op">.</span>x<span class="op">)</span> <span class="op">/</span> WARP_SIZE<span class="op">;</span></span>
<span id="annotated-cell-3-21"><a href="#annotated-cell-3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-22"><a href="#annotated-cell-3-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Declare fragments</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="1">1</button><span id="annotated-cell-3-23" class="code-annotation-target"><a href="#annotated-cell-3-23" aria-hidden="true" tabindex="-1"></a>    wmma<span class="op">::</span>fragment<span class="op">&lt;</span>wmma<span class="op">::</span>matrix_a<span class="op">,</span> <span class="dv">16</span><span class="op">,</span> <span class="dv">16</span><span class="op">,</span> <span class="dv">16</span><span class="op">,</span> half<span class="op">,</span> wmma<span class="op">::</span>row_major<span class="op">&gt;</span> A_frag<span class="op">;</span></span>
<span id="annotated-cell-3-24"><a href="#annotated-cell-3-24" aria-hidden="true" tabindex="-1"></a>    wmma<span class="op">::</span>fragment<span class="op">&lt;</span>wmma<span class="op">::</span>matrix_b<span class="op">,</span> <span class="dv">16</span><span class="op">,</span> <span class="dv">16</span><span class="op">,</span> <span class="dv">16</span><span class="op">,</span> half<span class="op">,</span> wmma<span class="op">::</span>row_major<span class="op">&gt;</span> B_frag<span class="op">;</span></span>
<span id="annotated-cell-3-25"><a href="#annotated-cell-3-25" aria-hidden="true" tabindex="-1"></a>    wmma<span class="op">::</span>fragment<span class="op">&lt;</span>wmma<span class="op">::</span>accumulator<span class="op">,</span> <span class="dv">16</span><span class="op">,</span> <span class="dv">16</span><span class="op">,</span> <span class="dv">16</span><span class="op">,</span> <span class="dt">float</span><span class="op">&gt;</span> accum_frag<span class="op">;</span></span>
<span id="annotated-cell-3-26"><a href="#annotated-cell-3-26" aria-hidden="true" tabindex="-1"></a>    wmma<span class="op">::</span>fragment<span class="op">&lt;</span>wmma<span class="op">::</span>accumulator<span class="op">,</span> <span class="dv">16</span><span class="op">,</span> <span class="dv">16</span><span class="op">,</span> <span class="dv">16</span><span class="op">,</span> half<span class="op">&gt;</span> C_frag<span class="op">;</span></span>
<span id="annotated-cell-3-27"><a href="#annotated-cell-3-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-28"><a href="#annotated-cell-3-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initialize the accumulator fragment for A * B with zeroes.</span></span>
<span id="annotated-cell-3-29"><a href="#annotated-cell-3-29" aria-hidden="true" tabindex="-1"></a>    wmma<span class="op">::</span>fill_fragment<span class="op">(</span>accum_frag<span class="op">,</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">);</span></span>
<span id="annotated-cell-3-30"><a href="#annotated-cell-3-30" aria-hidden="true" tabindex="-1"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="2">2</button><span id="annotated-cell-3-31" class="code-annotation-target"><a href="#annotated-cell-3-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> K<span class="op">;</span> i <span class="op">+=</span> <span class="dv">16</span><span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-3-32"><a href="#annotated-cell-3-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Get the starting row and column of our 16 x 16 tiles in both A and B.</span></span>
<span id="annotated-cell-3-33"><a href="#annotated-cell-3-33" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> row_A <span class="op">=</span> warp_row <span class="op">*</span> <span class="dv">16</span><span class="op">;</span></span>
<span id="annotated-cell-3-34"><a href="#annotated-cell-3-34" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> col_A <span class="op">=</span> i<span class="op">;</span></span>
<span id="annotated-cell-3-35"><a href="#annotated-cell-3-35" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> row_B <span class="op">=</span> i<span class="op">;</span></span>
<span id="annotated-cell-3-36"><a href="#annotated-cell-3-36" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> col_B <span class="op">=</span> warp_col <span class="op">*</span> <span class="dv">16</span><span class="op">;</span></span>
<span id="annotated-cell-3-37"><a href="#annotated-cell-3-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-38"><a href="#annotated-cell-3-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Check bounds</span></span>
<span id="annotated-cell-3-39"><a href="#annotated-cell-3-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>row_A <span class="op">&lt;</span> M <span class="op">&amp;&amp;</span> col_A <span class="op">&lt;</span> K <span class="op">&amp;&amp;</span> row_B <span class="op">&lt;</span> K <span class="op">&amp;&amp;</span> col_B <span class="op">&lt;</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-3-40"><a href="#annotated-cell-3-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-41"><a href="#annotated-cell-3-41" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Load matrices. </span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="3">3</button><span id="annotated-cell-3-42" class="code-annotation-target"><a href="#annotated-cell-3-42" aria-hidden="true" tabindex="-1"></a>            wmma<span class="op">::</span>load_matrix_sync<span class="op">(</span>A_frag<span class="op">,</span> A <span class="op">+</span> row_A <span class="op">*</span> lead_dim_A <span class="op">+</span> col_A<span class="op">,</span> lead_dim_A<span class="op">);</span></span>
<span id="annotated-cell-3-43"><a href="#annotated-cell-3-43" aria-hidden="true" tabindex="-1"></a>            wmma<span class="op">::</span>load_matrix_sync<span class="op">(</span>B_frag<span class="op">,</span> B <span class="op">+</span> row_B <span class="op">*</span> lead_dim_B <span class="op">+</span> col_B<span class="op">,</span> lead_dim_B<span class="op">);</span></span>
<span id="annotated-cell-3-44"><a href="#annotated-cell-3-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-45"><a href="#annotated-cell-3-45" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Perform MMA. </span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="4">4</button><span id="annotated-cell-3-46" class="code-annotation-target"><a href="#annotated-cell-3-46" aria-hidden="true" tabindex="-1"></a>            wmma<span class="op">::</span>mma_sync<span class="op">(</span>accum_frag<span class="op">,</span> A_frag<span class="op">,</span> B_frag<span class="op">,</span> accum_frag<span class="op">);</span></span>
<span id="annotated-cell-3-47"><a href="#annotated-cell-3-47" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-3-48"><a href="#annotated-cell-3-48" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-3-49"><a href="#annotated-cell-3-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-50"><a href="#annotated-cell-3-50" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> row_C <span class="op">=</span> warp_row <span class="op">*</span> <span class="dv">16</span><span class="op">;</span></span>
<span id="annotated-cell-3-51"><a href="#annotated-cell-3-51" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> col_C <span class="op">=</span> warp_col <span class="op">*</span> <span class="dv">16</span><span class="op">;</span></span>
<span id="annotated-cell-3-52"><a href="#annotated-cell-3-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-53"><a href="#annotated-cell-3-53" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Complete the GEMM operation: scale and add result fragments, then write to global memory</span></span>
<span id="annotated-cell-3-54"><a href="#annotated-cell-3-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>row_C <span class="op">&lt;</span> M <span class="op">&amp;&amp;</span> col_C <span class="op">&lt;</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-3-55"><a href="#annotated-cell-3-55" aria-hidden="true" tabindex="-1"></a>        wmma<span class="op">::</span>load_matrix_sync<span class="op">(</span>C_frag<span class="op">,</span> C <span class="op">+</span> row_C <span class="op">*</span> lead_dim_C <span class="op">+</span> col_C<span class="op">,</span> lead_dim_C<span class="op">,</span> wmma<span class="op">::</span>mem_row_major<span class="op">);</span></span>
<span id="annotated-cell-3-56"><a href="#annotated-cell-3-56" aria-hidden="true" tabindex="-1"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="5">5</button><span id="annotated-cell-3-57" class="code-annotation-target"><a href="#annotated-cell-3-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> C_frag<span class="op">.</span>num_elements<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-3-58"><a href="#annotated-cell-3-58" aria-hidden="true" tabindex="-1"></a>            C_frag<span class="op">.</span>x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> __float2half<span class="op">(</span>alpha <span class="op">*</span> accum_frag<span class="op">.</span>x<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> beta <span class="op">*</span> __half2float<span class="op">(</span>C_frag<span class="op">.</span>x<span class="op">[</span>i<span class="op">]));</span></span>
<span id="annotated-cell-3-59"><a href="#annotated-cell-3-59" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-3-60"><a href="#annotated-cell-3-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-61"><a href="#annotated-cell-3-61" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Store the result in global memory</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="6">6</button><span id="annotated-cell-3-62" class="code-annotation-target"><a href="#annotated-cell-3-62" aria-hidden="true" tabindex="-1"></a>        wmma<span class="op">::</span>store_matrix_sync<span class="op">(</span>C <span class="op">+</span> row_C <span class="op">*</span> lead_dim_C <span class="op">+</span> col_C<span class="op">,</span> C_frag<span class="op">,</span> lead_dim_C<span class="op">,</span> wmma<span class="op">::</span>mem_row_major<span class="op">);</span></span>
<span id="annotated-cell-3-63"><a href="#annotated-cell-3-63" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-3-64"><a href="#annotated-cell-3-64" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="annotated-cell-3-65"><a href="#annotated-cell-3-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-66"><a href="#annotated-cell-3-66" aria-hidden="true" tabindex="-1"></a><span class="co">// Same as in Tiled Matrix Multiplication</span></span>
<span id="annotated-cell-3-67"><a href="#annotated-cell-3-67" aria-hidden="true" tabindex="-1"></a>__global__ <span class="dt">void</span> gemm_tiled_kernel<span class="op">(</span><span class="at">const</span> half<span class="op">*</span> A<span class="op">,</span> <span class="at">const</span> half<span class="op">*</span> B<span class="op">,</span> half<span class="op">*</span> C<span class="op">,</span> <span class="dt">int</span> M<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> K<span class="op">,</span> <span class="dt">float</span> alpha<span class="op">,</span> <span class="dt">float</span> beta<span class="op">)</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="annotated-cell-3-68"><a href="#annotated-cell-3-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-69"><a href="#annotated-cell-3-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-70"><a href="#annotated-cell-3-70" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> <span class="st">"C"</span> <span class="dt">void</span> solve<span class="op">(</span><span class="at">const</span> half<span class="op">*</span> A<span class="op">,</span> <span class="at">const</span> half<span class="op">*</span> B<span class="op">,</span> half<span class="op">*</span> C<span class="op">,</span> <span class="dt">int</span> M<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> K<span class="op">,</span> <span class="dt">float</span> alpha<span class="op">,</span> <span class="dt">float</span> beta<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-3-71"><a href="#annotated-cell-3-71" aria-hidden="true" tabindex="-1"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="7">7</button><span id="annotated-cell-3-72" class="code-annotation-target"><a href="#annotated-cell-3-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>M <span class="op">%</span> <span class="dv">16</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> N <span class="op">%</span> <span class="dv">16</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> K <span class="op">%</span> <span class="dv">16</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-3-73"><a href="#annotated-cell-3-73" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">int</span> WARPS_X <span class="op">=</span> <span class="dv">4</span><span class="op">,</span> WARPS_Y <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="8">8</button><span id="annotated-cell-3-74" class="code-annotation-target"><a href="#annotated-cell-3-74" aria-hidden="true" tabindex="-1"></a>        dim3 blockDim<span class="op">(</span>WARPS_X <span class="op">*</span> WARP_SIZE<span class="op">,</span> WARPS_Y<span class="op">);</span></span>
<span id="annotated-cell-3-75"><a href="#annotated-cell-3-75" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="annotated-cell-3-76"><a href="#annotated-cell-3-76" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> num_col_tiles <span class="op">=</span> N <span class="op">/</span> <span class="dv">16</span><span class="op">;</span></span>
<span id="annotated-cell-3-77"><a href="#annotated-cell-3-77" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> num_row_tiles <span class="op">=</span> M <span class="op">/</span> <span class="dv">16</span><span class="op">;</span></span>
<span id="annotated-cell-3-78"><a href="#annotated-cell-3-78" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="annotated-cell-3-79"><a href="#annotated-cell-3-79" aria-hidden="true" tabindex="-1"></a>        dim3 gridDim<span class="op">(</span></span>
<span id="annotated-cell-3-80"><a href="#annotated-cell-3-80" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span>num_col_tiles <span class="op">+</span> WARPS_X <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> WARPS_X<span class="op">,</span></span>
<span id="annotated-cell-3-81"><a href="#annotated-cell-3-81" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span>num_row_tiles <span class="op">+</span> WARPS_Y <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> WARPS_Y</span>
<span id="annotated-cell-3-82"><a href="#annotated-cell-3-82" aria-hidden="true" tabindex="-1"></a>        <span class="op">);</span></span>
<span id="annotated-cell-3-83"><a href="#annotated-cell-3-83" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="annotated-cell-3-84"><a href="#annotated-cell-3-84" aria-hidden="true" tabindex="-1"></a>        gemm_wmma<span class="op">&lt;&lt;&lt;</span>gridDim<span class="op">,</span> blockDim<span class="op">&gt;&gt;&gt;(</span>A<span class="op">,</span> B<span class="op">,</span> C<span class="op">,</span> M<span class="op">,</span> N<span class="op">,</span> K<span class="op">,</span> alpha<span class="op">,</span> beta<span class="op">);</span></span>
<span id="annotated-cell-3-85"><a href="#annotated-cell-3-85" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="annotated-cell-3-86"><a href="#annotated-cell-3-86" aria-hidden="true" tabindex="-1"></a>        dim3 block<span class="op">(</span>TILE_WIDTH<span class="op">,</span> TILE_WIDTH<span class="op">);</span></span>
<span id="annotated-cell-3-87"><a href="#annotated-cell-3-87" aria-hidden="true" tabindex="-1"></a>        dim3 grid<span class="op">(</span></span>
<span id="annotated-cell-3-88"><a href="#annotated-cell-3-88" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span>N <span class="op">+</span> <span class="op">(</span>TILE_WIDTH <span class="op">*</span> COARSE_FACTOR<span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span>TILE_WIDTH <span class="op">*</span> COARSE_FACTOR<span class="op">),</span> </span>
<span id="annotated-cell-3-89"><a href="#annotated-cell-3-89" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span>M <span class="op">+</span> TILE_WIDTH <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> TILE_WIDTH</span>
<span id="annotated-cell-3-90"><a href="#annotated-cell-3-90" aria-hidden="true" tabindex="-1"></a>        <span class="op">);</span></span>
<span id="annotated-cell-3-91"><a href="#annotated-cell-3-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-92"><a href="#annotated-cell-3-92" aria-hidden="true" tabindex="-1"></a>        gemm_tiled_kernel<span class="op">&lt;&lt;&lt;</span>grid<span class="op">,</span> block<span class="op">&gt;&gt;&gt;(</span>A<span class="op">,</span> B<span class="op">,</span> C<span class="op">,</span> M<span class="op">,</span> N<span class="op">,</span> K<span class="op">,</span> alpha<span class="op">,</span> beta<span class="op">);</span></span>
<span id="annotated-cell-3-93"><a href="#annotated-cell-3-93" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-3-94"><a href="#annotated-cell-3-94" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-3" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="23" data-code-annotation="1"><strong>Fragments</strong>: The operand matrices must be represented in the registers of Tensor Cores before MMA is performed. Since MMA is a warp-wide operation, these registers are distributed between the threads of a warp. Each thread holds a fragment of the overall matrix. A fragment is a templated type that accepts parameters for: the matrix the fragment holds, the shape of the overall operation, the data type, and whether the data is row or column major for the operand matrices. We pass in 16 three times for the shape of the overall operation to represent that the number of rows the fragment stores, the number of columns the fragment stores, and the dot product length are all 16.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="31" data-code-annotation="2"><strong>The K-loop</strong>: Each warp computes one 16 x 16 tile of A * B. We loop over rows of A and columns of B. Each row of A and column of B has K elements. Overall, we are computing a 16 x 16 output tile in C: C (16 x 16) = A (16 x K) * B(K x 16). However, we can only store and use 16 x 16 chunks of A and B at once for the MMA operation. Therefore we need to split K into chunks of 16. On each loop iteration, we accumulate C (16 x 16) += A (16 x 16) * B (16 x 16).</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="42" data-code-annotation="3"><strong>Loading into a fragment</strong>: To load data into a fragment, we need to specify the fragment to load into, the pointer to the memory we are loading from, and the leading dimension of the matrix (so that the operation knows the stride length between rows for a row-major matrix, or between columns for a column-major matrix).</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="46" data-code-annotation="4"><strong>Matrix Multiply Accumulate</strong>: Computes Arg1 = Arg2 * Arg3 + Arg4.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="57" data-code-annotation="5"><strong>Modifying data within fragments</strong>: There are 16 x 16 = 256 elements in C_frag and 32 threads per warp. Each thread therefore holds 256 / 32 = 8 elements. So the loop will have 8 iterations. The fragment’s internal storage is opaque - we don’t know which thread holds each element. Luckily, this doesn’t matter for element-wise operations like scaling. What about for accum_frag and C_frag? As they are declared with identical template parameters, they are guaranteed to have the same internal layout. Hence we can be sure we are adding the correct corresponding elements.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="6">6</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="62" data-code-annotation="6"><strong>Storing back to global memory</strong>: Here we need to pass the pointer to memory that we are storing into, the fragment we are loading from, the leading dimension of the matrix, and whether the matrix is row or column major.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="7">7</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="72" data-code-annotation="7"><strong>Restrictions on WMMA</strong>: WMMA strictly handles 16x16x16 operations only, so we need to check that our matrix dimensions are multiples of 16. If not, we’ll launch our tiled GEMM kernel. In a later section, we will adjust our WMMA kernel to handle arbitrary matrix dimensions.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="8">8</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="74" data-code-annotation="8"><strong>Grid Dimensions</strong>: This works out to be (128, 4), so we have 512 total threads per block. Each row in our block has 128 threads, so a total of 4 warps, and then we have 4 rows, so we essentially have a 4x4 grid of warps in each block. Since each warp computes a 16x16 output tile, each warp is handling the same output as each block did in our tiled GEMM kernel. Since each block has a 4x4 grid of warps, we are then computing a 64x64 output tile of C for each block. We know that our matrix dimensions are divisible by 16, but they may not be divisible by 64. So at the blocks at the edge of our grid, we may have some warps that fall out of bounds of C. Luckily we have the necessary boundary checks in our kernel, so we just need to do our ceiling division here to ensure our blocks fully cover C, without worrying about if some of them go beyond the edges of C.</span>
</dd>
</dl>
</section>
<section id="arithmetic-intensity-2" class="level3">
<h3 class="anchored" data-anchor-id="arithmetic-intensity-2">Arithmetic Intensity</h3>
<p>To calculate the arithmetic intensity of this kernel, we will focus on the main loop where the loading from global memory and MMA operations happen. On each loop iteration, a warp collectively loads one 16x16 tile from each of A and B. So we retrieve 512 half-precision floats for a total of 1024 bytes. Then we are modifying the running sums for a 16x16 output tile in C. For each pixel in this output tile, we are taking a dot product of two 16-element vectors, so we perform 16 multiplications and 16 additions. Therefore we perform 32 FLOPs for each pixel in the 16x16 output tile, for a total of 8192 FLOPs. Therefore, our arithmetic intensity is approximately 8192 / 1024 = 8 FLOPs/B.</p>
<p>Notice that this is exactly the same as the arithmetic intensity of our previous tiled matrix multiplication kernel. In this kernel, I avoided using shared memory so that I could have a very simple and clear WMMA implementation. However, in reality, we can make use of the same collaborative shared memory loading technique from our prior kernel to improve the arithmetic intensity of our WMMA kernel even further. I will do exactly this (among other improvements) in subsequent sections. The other aspect that I observed with this kernel is that despite having the same arithmetic intensity as our tiled matrix multiplication, it is significantly faster. This is because WMMA is a hardware-native operation. In the section introduction, we discussed the anatomy of an WMMA operation and why it is so fast, but I’ll call out a few ways the arithmetic intensity here is misleading. First, although it is standard to count multiplication and addition as separate FLOPs, they are fused into a single operation on the hardware when using tensor cores. Second, we discussed that WMMA fragments live on registers instead of shared memory. This is not reflected in our arithmetic intensity (which only takes into account global memory accesses). After accessing global memory in our tiled GEMM kernel, we have just transferred it to shared memory, so we still have to pull our data again from shared memory to our compute cores. Here, we load from global memory directly to the registers of the Tensor Core.</p>
</section>
<section id="benchmarks-2" class="level3">
<h3 class="anchored" data-anchor-id="benchmarks-2">Benchmarks</h3>
<table class="table">
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">GPU Model</th>
<th style="text-align: left;">Memory Bandwidth</th>
<th style="text-align: left;">Peak FP16 Compute</th>
<th style="text-align: left;">Ridge Point (FLOP/Byte)</th>
<th style="text-align: left;">Runtime (ms)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>NVIDIA T4</strong></td>
<td style="text-align: left;">320 GB/s</td>
<td style="text-align: left;">65 TFLOPS</td>
<td style="text-align: left;">203</td>
<td style="text-align: left;">1.68</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>NVIDIA A100 (80GB)</strong></td>
<td style="text-align: left;">2,039 GB/s</td>
<td style="text-align: left;">312 TFLOPS</td>
<td style="text-align: left;">153</td>
<td style="text-align: left;">0.17</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>NVIDIA H100 (SXM)</strong></td>
<td style="text-align: left;">3,350 GB/s</td>
<td style="text-align: left;">989 TFLOPS</td>
<td style="text-align: left;">295</td>
<td style="text-align: left;">0.10</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>NVIDIA H200 (SXM)</strong></td>
<td style="text-align: left;">4,800 GB/s</td>
<td style="text-align: left;">989 TFLOPS</td>
<td style="text-align: left;">206</td>
<td style="text-align: left;">0.10</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>NVIDIA B200</strong></td>
<td style="text-align: left;">8,000 GB/s</td>
<td style="text-align: left;">2,500 TFLOPS</td>
<td style="text-align: left;">312</td>
<td style="text-align: left;">0.10</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="double-buffer" class="level2">
<h2 class="anchored" data-anchor-id="double-buffer">4. Double Buffer</h2>
<p>The next improvement we can make to our kernel is the use of a double buffer. The goal of a double buffer is to hide the latency of fetching data from global memory. In our current implementation, when threads request data from global memory, the compute cores have to pause while we wait for the data to arrive. Then we start computing, but our memory units are now sitting idle. When we’re done, we request data again and repeat the cycle. At any given time, either our compute cores or memory units are sitting idle.</p>
<p>Instead, before we compute the current tile, we can issue an asynchronous request to load data for the next tile. Then our memory bus will load data in for the next tile while we compute the current tile. There is a dedicated hardware unit in the GPU that handles this asynchronous loading, the Async Copy Engine.</p>
<p>The double buffer is so named because we declare shared memory that is double the size of what we need to compute on. That way, we can use half of the buffer to load the next tiles of A and B from global memory to shared memory, and the other half of the buffer holds the currently loaded data that we feed to our Tensor Cores. We can track which half of the buffer is ready and which is being loaded. So our process is as follows within each loop iteration:</p>
<ol type="1">
<li>Asynchronously request data for the next tile to the half of the buffer we are not about to use.</li>
<li>WMMA compute on the current tile, using the half of the buffer that is ready.</li>
<li>Barrier wait until the asynchronous request is complete. Then swap the <code>stage</code> index that tells us which half of the buffer is ready, and proceed to the next loop iteration.</li>
</ol>
<p>There are a few other optimizations related to the data loading and grid configuration that we’ll pack into this kernel that warrant some explanation ahead of time. First, we will have each block be composed of 4 warps in a 2 x 2 grid (so 128 total threads). Each warp will be responsible for computing a 32 x 32 output tile of C, so in total one block will compute a 64 x 64 output tile.</p>
<p>To accomplish this, we will still loop over the K-dimension in a wide row in A and wide column in B, just as pictured in the image from tiled matrix multiplication. However, we will specify the wide row in A to have 64 rows, and the wide column in B to have 64 columns. We still loop over K via increments of 16 at a time. So in each loop iteration over K, we will use a 64 x 16 chunk of A and a 16 x 64 chunk of B. This is the same process as tiled matrix multiplication, but we are now using a non-square tile.</p>
<p>Because we have a 2 x 2 grid of warps, each warp will use a 32 x 16 chunk of A and a 16 x 32 chunk of B, and perform 4 WMMA operations (since they only take matrices of size 16 x 16). We then add their output to our accumulator fragments (4 for each warp, since each WMMA operation accumulates to a different 16 x 16 output tile) in each loop iteration. By the time our K loop is complete, our block has fully computed the value of <span class="math inline">\(A \times B\)</span> for a 64 x 64 tile of C.</p>
<p>The reason we do this is similar to why we loaded to shared memory in our tiled GEMM: we want to avoid redundant data loading and load as much data from global memory at once as we can usefully share across our block. By arranging our warps in 2 x 2 grid, we also are able to reuse more memory than if they were arranged in a straight line. For the collaborative data loading, we will use the thread ID in the block to determine what part of the current A (64 x 16) and B (16 x 64) chunks this thread will load. Each of these chunks can be treated as 128 8-half vectors, so each thread should load 8 elements. To reduce the number of instructions to load from global memory, we will employ vectorized loads to load 8 halves at once. Therefore, our A chunk can be viewed as 64 rows of 2 vectors, and our B chunk can be viewed as 8 rows of 8 vectors. We will use a vectorized store to global memory in the final section too, when possible.</p>
<section id="annotated-code-3" class="level3">
<h3 class="anchored" data-anchor-id="annotated-code-3">Annotated Code</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="annotated-cell-4"><pre class="sourceCode cpp code-annotation-code code-with-copy code-annotated"><code class="sourceCode cpp"><span id="annotated-cell-4-1"><a href="#annotated-cell-4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cuda_runtime.h&gt;</span></span>
<span id="annotated-cell-4-2"><a href="#annotated-cell-4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cuda_fp16.h&gt;</span></span>
<span id="annotated-cell-4-3"><a href="#annotated-cell-4-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;mma.h&gt;</span></span>
<span id="annotated-cell-4-4"><a href="#annotated-cell-4-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cuda_pipeline_primitives.h&gt;</span></span>
<span id="annotated-cell-4-5"><a href="#annotated-cell-4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-6"><a href="#annotated-cell-4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> nvcuda<span class="op">;</span></span>
<span id="annotated-cell-4-7"><a href="#annotated-cell-4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-8"><a href="#annotated-cell-4-8" aria-hidden="true" tabindex="-1"></a><span class="co">// ------------- CONFIGURATION -------------</span></span>
<span id="annotated-cell-4-9"><a href="#annotated-cell-4-9" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> BLOCK_M <span class="op">=</span> <span class="dv">64</span><span class="op">;</span></span>
<span id="annotated-cell-4-10"><a href="#annotated-cell-4-10" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> BLOCK_N <span class="op">=</span> <span class="dv">64</span><span class="op">;</span> <span class="co">// One block computes a 64 x 64 tile of the output matrix</span></span>
<span id="annotated-cell-4-11"><a href="#annotated-cell-4-11" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> BLOCK_K <span class="op">=</span> <span class="dv">16</span><span class="op">;</span> <span class="co">// Accumulation step</span></span>
<span id="annotated-cell-4-12"><a href="#annotated-cell-4-12" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> WARP_SIZE <span class="op">=</span> <span class="dv">32</span><span class="op">;</span></span>
<span id="annotated-cell-4-13"><a href="#annotated-cell-4-13" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> THREAD_COUNT <span class="op">=</span> <span class="dv">128</span><span class="op">;</span></span>
<span id="annotated-cell-4-14"><a href="#annotated-cell-4-14" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> WMMA <span class="op">=</span> <span class="dv">16</span><span class="op">;</span></span>
<span id="annotated-cell-4-15"><a href="#annotated-cell-4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-16"><a href="#annotated-cell-4-16" aria-hidden="true" tabindex="-1"></a>__global__ <span class="dt">void</span> gemm_buffer_kernel<span class="op">(</span><span class="at">const</span> half<span class="op">*</span> A<span class="op">,</span> <span class="at">const</span> half<span class="op">*</span> B<span class="op">,</span> half<span class="op">*</span> C<span class="op">,</span> <span class="dt">int</span> M<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> K<span class="op">,</span> <span class="dt">float</span> alpha<span class="op">,</span> <span class="dt">float</span> beta<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-4-17"><a href="#annotated-cell-4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-18"><a href="#annotated-cell-4-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------------- INDEX CALCULATIONS -------------</span></span>
<span id="annotated-cell-4-19"><a href="#annotated-cell-4-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Linear view for data loading: which worker out of 128 threads am I?</span></span>
<span id="annotated-cell-4-20"><a href="#annotated-cell-4-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tid <span class="op">=</span> threadIdx<span class="op">.</span>x<span class="op">;</span></span>
<span id="annotated-cell-4-21"><a href="#annotated-cell-4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-22"><a href="#annotated-cell-4-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Global position: what tile of the output matrix am I calculating?</span></span>
<span id="annotated-cell-4-23"><a href="#annotated-cell-4-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> block_row_start <span class="op">=</span> blockIdx<span class="op">.</span>y <span class="op">*</span> BLOCK_M<span class="op">;</span></span>
<span id="annotated-cell-4-24"><a href="#annotated-cell-4-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> block_col_start <span class="op">=</span> blockIdx<span class="op">.</span>x <span class="op">*</span> BLOCK_N<span class="op">;</span></span>
<span id="annotated-cell-4-25"><a href="#annotated-cell-4-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-26"><a href="#annotated-cell-4-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// What warp am I in the 2x2 grid?</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="1">1</button><span id="annotated-cell-4-27" class="code-annotation-target"><a href="#annotated-cell-4-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> warp_id <span class="op">=</span> tid <span class="op">/</span> WARP_SIZE<span class="op">;</span></span>
<span id="annotated-cell-4-28"><a href="#annotated-cell-4-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> warp_row <span class="op">=</span> <span class="op">(</span>warp_id <span class="op">/</span> <span class="dv">2</span><span class="op">)</span> <span class="op">*</span> <span class="dv">32</span><span class="op">;</span></span>
<span id="annotated-cell-4-29"><a href="#annotated-cell-4-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> warp_col <span class="op">=</span> <span class="op">(</span>warp_id <span class="op">%</span> <span class="dv">2</span><span class="op">)</span> <span class="op">*</span> <span class="dv">32</span><span class="op">;</span></span>
<span id="annotated-cell-4-30"><a href="#annotated-cell-4-30" aria-hidden="true" tabindex="-1"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="2">2</button><span id="annotated-cell-4-31" class="code-annotation-target"><a href="#annotated-cell-4-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-32"><a href="#annotated-cell-4-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">// A tile: 64 x 16. Each row has 2 8-element vectors. </span></span>
<span id="annotated-cell-4-33"><a href="#annotated-cell-4-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> row_A <span class="op">=</span> tid <span class="op">/</span> <span class="dv">2</span><span class="op">;</span>       <span class="co">// 0 to 63</span></span>
<span id="annotated-cell-4-34"><a href="#annotated-cell-4-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> col_A <span class="op">=</span> <span class="op">(</span>tid <span class="op">%</span> <span class="dv">2</span><span class="op">)</span> <span class="op">*</span> <span class="dv">8</span><span class="op">;</span> <span class="co">// 0 or 8</span></span>
<span id="annotated-cell-4-35"><a href="#annotated-cell-4-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// B tile: 16 x 64. Each row has 8 8-element vectors. </span></span>
<span id="annotated-cell-4-36"><a href="#annotated-cell-4-36" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> row_B <span class="op">=</span> tid <span class="op">/</span> <span class="dv">8</span><span class="op">;</span>       <span class="co">// 0 to 7</span></span>
<span id="annotated-cell-4-37"><a href="#annotated-cell-4-37" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> col_B <span class="op">=</span> <span class="op">(</span>tid <span class="op">%</span> <span class="dv">8</span><span class="op">)</span> <span class="op">*</span> <span class="dv">8</span><span class="op">;</span> <span class="co">// 0, 8, 16, 24, 32, 40, 48, or 56</span></span>
<span id="annotated-cell-4-38"><a href="#annotated-cell-4-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ----------------------------------------------</span></span>
<span id="annotated-cell-4-39"><a href="#annotated-cell-4-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-40"><a href="#annotated-cell-4-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-41"><a href="#annotated-cell-4-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------------- MEMORY INITIALIZATION ----------</span></span>
<span id="annotated-cell-4-42"><a href="#annotated-cell-4-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Double Buffer: Shared Memory</span></span>
<span id="annotated-cell-4-43"><a href="#annotated-cell-4-43" aria-hidden="true" tabindex="-1"></a>    __shared__ half sA<span class="op">[</span><span class="dv">2</span><span class="op">][</span>BLOCK_M <span class="op">*</span> BLOCK_K<span class="op">];</span> <span class="co">// 64 rows, 16 cols (K)</span></span>
<span id="annotated-cell-4-44"><a href="#annotated-cell-4-44" aria-hidden="true" tabindex="-1"></a>    __shared__ half sB<span class="op">[</span><span class="dv">2</span><span class="op">][</span>BLOCK_K <span class="op">*</span> BLOCK_N<span class="op">];</span> <span class="co">// 16 rows (K), 64 cols</span></span>
<span id="annotated-cell-4-45"><a href="#annotated-cell-4-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-46"><a href="#annotated-cell-4-46" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Declare fragments and initialize accumulator. </span></span>
<span id="annotated-cell-4-47"><a href="#annotated-cell-4-47" aria-hidden="true" tabindex="-1"></a>    wmma<span class="op">::</span>fragment<span class="op">&lt;</span>wmma<span class="op">::</span>matrix_a<span class="op">,</span> WMMA<span class="op">,</span> WMMA<span class="op">,</span> WMMA<span class="op">,</span> half<span class="op">,</span> wmma<span class="op">::</span>row_major<span class="op">&gt;</span> a_frag<span class="op">;</span></span>
<span id="annotated-cell-4-48"><a href="#annotated-cell-4-48" aria-hidden="true" tabindex="-1"></a>    wmma<span class="op">::</span>fragment<span class="op">&lt;</span>wmma<span class="op">::</span>matrix_b<span class="op">,</span> WMMA<span class="op">,</span> WMMA<span class="op">,</span> WMMA<span class="op">,</span> half<span class="op">,</span> wmma<span class="op">::</span>row_major<span class="op">&gt;</span> b_frag<span class="op">;</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="3">3</button><span id="annotated-cell-4-49" class="code-annotation-target"><a href="#annotated-cell-4-49" aria-hidden="true" tabindex="-1"></a>    wmma<span class="op">::</span>fragment<span class="op">&lt;</span>wmma<span class="op">::</span>accumulator<span class="op">,</span> WMMA<span class="op">,</span> WMMA<span class="op">,</span> WMMA<span class="op">,</span> <span class="dt">float</span><span class="op">&gt;</span> accum_frag<span class="op">[</span><span class="dv">2</span><span class="op">][</span><span class="dv">2</span><span class="op">];</span></span>
<span id="annotated-cell-4-50"><a href="#annotated-cell-4-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-51"><a href="#annotated-cell-4-51" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-4-52"><a href="#annotated-cell-4-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-4-53"><a href="#annotated-cell-4-53" aria-hidden="true" tabindex="-1"></a>        <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-4-54"><a href="#annotated-cell-4-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-4-55"><a href="#annotated-cell-4-55" aria-hidden="true" tabindex="-1"></a>            wmma<span class="op">::</span>fill_fragment<span class="op">(</span>accum_frag<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">);</span></span>
<span id="annotated-cell-4-56"><a href="#annotated-cell-4-56" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-4-57"><a href="#annotated-cell-4-57" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-4-58"><a href="#annotated-cell-4-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-59"><a href="#annotated-cell-4-59" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Pipeline setup</span></span>
<span id="annotated-cell-4-60"><a href="#annotated-cell-4-60" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> stage <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Alternates between 0 and 1</span></span>
<span id="annotated-cell-4-61"><a href="#annotated-cell-4-61" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ----------------------------------------------</span></span>
<span id="annotated-cell-4-62"><a href="#annotated-cell-4-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-63"><a href="#annotated-cell-4-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-64"><a href="#annotated-cell-4-64" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------------- PROLOGUE -------------</span></span>
<span id="annotated-cell-4-65"><a href="#annotated-cell-4-65" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Load the first tile. </span></span>
<span id="annotated-cell-4-66"><a href="#annotated-cell-4-66" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="annotated-cell-4-67"><a href="#annotated-cell-4-67" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> half<span class="op">*</span> src_A <span class="op">=</span> A <span class="op">+</span> <span class="op">(</span>block_row_start <span class="op">+</span> row_A<span class="op">)</span> <span class="op">*</span> K <span class="op">+</span> <span class="op">(</span><span class="dv">0</span> <span class="op">+</span> col_A<span class="op">);</span></span>
<span id="annotated-cell-4-68"><a href="#annotated-cell-4-68" aria-hidden="true" tabindex="-1"></a>        half<span class="op">*</span> dst_A <span class="op">=</span> <span class="op">&amp;</span>sA<span class="op">[</span>stage<span class="op">][</span>row_A <span class="op">*</span> BLOCK_K <span class="op">+</span> col_A<span class="op">];</span></span>
<span id="annotated-cell-4-69"><a href="#annotated-cell-4-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-70"><a href="#annotated-cell-4-70" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> half<span class="op">*</span> src_B <span class="op">=</span> B <span class="op">+</span> <span class="op">(</span><span class="dv">0</span> <span class="op">+</span> row_B<span class="op">)</span> <span class="op">*</span> N <span class="op">+</span> <span class="op">(</span>block_col_start <span class="op">+</span> col_B<span class="op">);</span></span>
<span id="annotated-cell-4-71"><a href="#annotated-cell-4-71" aria-hidden="true" tabindex="-1"></a>        half<span class="op">*</span> dst_B <span class="op">=</span> <span class="op">&amp;</span>sB<span class="op">[</span>stage<span class="op">][</span>row_B <span class="op">*</span> BLOCK_N <span class="op">+</span> col_B<span class="op">];</span></span>
<span id="annotated-cell-4-72"><a href="#annotated-cell-4-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-73"><a href="#annotated-cell-4-73" aria-hidden="true" tabindex="-1"></a>        <span class="co">//&nbsp;Async copy. int4 is the size of 8 half elements</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="4">4</button><span id="annotated-cell-4-74" class="code-annotation-target"><a href="#annotated-cell-4-74" aria-hidden="true" tabindex="-1"></a>        __pipeline_memcpy_async<span class="op">(</span>dst_A<span class="op">,</span> src_A<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>int4<span class="op">));</span></span>
<span id="annotated-cell-4-75"><a href="#annotated-cell-4-75" aria-hidden="true" tabindex="-1"></a>        __pipeline_memcpy_async<span class="op">(</span>dst_B<span class="op">,</span> src_B<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>int4<span class="op">));</span> </span>
<span id="annotated-cell-4-76"><a href="#annotated-cell-4-76" aria-hidden="true" tabindex="-1"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="5">5</button><span id="annotated-cell-4-77" class="code-annotation-target"><a href="#annotated-cell-4-77" aria-hidden="true" tabindex="-1"></a>        __pipeline_commit<span class="op">();</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="6">6</button><span id="annotated-cell-4-78" class="code-annotation-target"><a href="#annotated-cell-4-78" aria-hidden="true" tabindex="-1"></a>        __pipeline_wait_prior<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="annotated-cell-4-79"><a href="#annotated-cell-4-79" aria-hidden="true" tabindex="-1"></a>        __syncthreads<span class="op">();</span></span>
<span id="annotated-cell-4-80"><a href="#annotated-cell-4-80" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-4-81"><a href="#annotated-cell-4-81" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------------------------------------</span></span>
<span id="annotated-cell-4-82"><a href="#annotated-cell-4-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-83"><a href="#annotated-cell-4-83" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------------- MAIN LOOP -------------</span></span>
<span id="annotated-cell-4-84"><a href="#annotated-cell-4-84" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-4-85"><a href="#annotated-cell-4-85" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> K<span class="op">;</span> k <span class="op">+=</span> BLOCK_K<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-4-86"><a href="#annotated-cell-4-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-87"><a href="#annotated-cell-4-87" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> k_next <span class="op">=</span> k <span class="op">+</span> BLOCK_K<span class="op">;</span></span>
<span id="annotated-cell-4-88"><a href="#annotated-cell-4-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-89"><a href="#annotated-cell-4-89" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 1. LOAD the next tile asynchronously</span></span>
<span id="annotated-cell-4-90"><a href="#annotated-cell-4-90" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k_next <span class="op">&lt;</span> K<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-4-91"><a href="#annotated-cell-4-91" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Turns 1 into 0 or 0 into 1</span></span>
<span id="annotated-cell-4-92"><a href="#annotated-cell-4-92" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> next_stage <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> stage<span class="op">;</span></span>
<span id="annotated-cell-4-93"><a href="#annotated-cell-4-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-94"><a href="#annotated-cell-4-94" aria-hidden="true" tabindex="-1"></a>            <span class="at">const</span> half<span class="op">*</span> src_A <span class="op">=</span> A <span class="op">+</span> <span class="op">(</span>block_row_start <span class="op">+</span> row_A<span class="op">)</span> <span class="op">*</span> K <span class="op">+</span> <span class="op">(</span>k_next <span class="op">+</span> col_A<span class="op">);</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="7">7</button><span id="annotated-cell-4-95" class="code-annotation-target"><a href="#annotated-cell-4-95" aria-hidden="true" tabindex="-1"></a>            half<span class="op">*</span> dst_A <span class="op">=</span> <span class="op">&amp;</span>sA<span class="op">[</span>next_stage<span class="op">][</span>row_A <span class="op">*</span> BLOCK_K <span class="op">+</span> col_A<span class="op">];</span></span>
<span id="annotated-cell-4-96"><a href="#annotated-cell-4-96" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="annotated-cell-4-97"><a href="#annotated-cell-4-97" aria-hidden="true" tabindex="-1"></a>            <span class="at">const</span> half<span class="op">*</span> src_B <span class="op">=</span> B <span class="op">+</span> <span class="op">(</span>k_next <span class="op">+</span> row_B<span class="op">)</span> <span class="op">*</span> N <span class="op">+</span> <span class="op">(</span>block_col_start <span class="op">+</span> col_B<span class="op">);</span></span>
<span id="annotated-cell-4-98"><a href="#annotated-cell-4-98" aria-hidden="true" tabindex="-1"></a>            half<span class="op">*</span> dst_B <span class="op">=</span> <span class="op">&amp;</span>sB<span class="op">[</span>next_stage<span class="op">][</span>row_B <span class="op">*</span> BLOCK_N <span class="op">+</span> col_B<span class="op">];</span></span>
<span id="annotated-cell-4-99"><a href="#annotated-cell-4-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-100"><a href="#annotated-cell-4-100" aria-hidden="true" tabindex="-1"></a>            __pipeline_memcpy_async<span class="op">(</span>dst_A<span class="op">,</span> src_A<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>int4<span class="op">));</span> </span>
<span id="annotated-cell-4-101"><a href="#annotated-cell-4-101" aria-hidden="true" tabindex="-1"></a>            __pipeline_memcpy_async<span class="op">(</span>dst_B<span class="op">,</span> src_B<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>int4<span class="op">));</span> </span>
<span id="annotated-cell-4-102"><a href="#annotated-cell-4-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-103"><a href="#annotated-cell-4-103" aria-hidden="true" tabindex="-1"></a>            __pipeline_commit<span class="op">();</span></span>
<span id="annotated-cell-4-104"><a href="#annotated-cell-4-104" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-4-105"><a href="#annotated-cell-4-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-106"><a href="#annotated-cell-4-106" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 2. MATH: process the current tile. Recall we have a 2 x 2 grid of 16 x 16 subtiles for each warp.</span></span>
<span id="annotated-cell-4-107"><a href="#annotated-cell-4-107" aria-hidden="true" tabindex="-1"></a>        <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-4-108"><a href="#annotated-cell-4-108" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-4-109"><a href="#annotated-cell-4-109" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-4-110"><a href="#annotated-cell-4-110" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-4-111"><a href="#annotated-cell-4-111" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Calculate pointer into shared memory for this sub-tile</span></span>
<span id="annotated-cell-4-112"><a href="#annotated-cell-4-112" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> smem_row <span class="op">=</span> warp_row <span class="op">+</span> <span class="op">(</span>i <span class="op">*</span> <span class="dv">16</span><span class="op">);</span></span>
<span id="annotated-cell-4-113"><a href="#annotated-cell-4-113" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> smem_col <span class="op">=</span> warp_col <span class="op">+</span> <span class="op">(</span>j <span class="op">*</span> <span class="dv">16</span><span class="op">);</span></span>
<span id="annotated-cell-4-114"><a href="#annotated-cell-4-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-115"><a href="#annotated-cell-4-115" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Load fragments from shared memory</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="8">8</button><span id="annotated-cell-4-116" class="code-annotation-target"><a href="#annotated-cell-4-116" aria-hidden="true" tabindex="-1"></a>                half<span class="op">*</span> tile_ptr_A <span class="op">=</span> <span class="op">&amp;</span>sA<span class="op">[</span>stage<span class="op">][</span>smem_row <span class="op">*</span> BLOCK_K<span class="op">];</span></span>
<span id="annotated-cell-4-117"><a href="#annotated-cell-4-117" aria-hidden="true" tabindex="-1"></a>                half<span class="op">*</span> tile_ptr_B <span class="op">=</span> <span class="op">&amp;</span>sB<span class="op">[</span>stage<span class="op">][</span>smem_col<span class="op">];</span></span>
<span id="annotated-cell-4-118"><a href="#annotated-cell-4-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-119"><a href="#annotated-cell-4-119" aria-hidden="true" tabindex="-1"></a>                wmma<span class="op">::</span>load_matrix_sync<span class="op">(</span>a_frag<span class="op">,</span> tile_ptr_A<span class="op">,</span> BLOCK_K<span class="op">);</span></span>
<span id="annotated-cell-4-120"><a href="#annotated-cell-4-120" aria-hidden="true" tabindex="-1"></a>                wmma<span class="op">::</span>load_matrix_sync<span class="op">(</span>b_frag<span class="op">,</span> tile_ptr_B<span class="op">,</span> BLOCK_N<span class="op">);</span></span>
<span id="annotated-cell-4-121"><a href="#annotated-cell-4-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-122"><a href="#annotated-cell-4-122" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Multiply matrices and accumulate</span></span>
<span id="annotated-cell-4-123"><a href="#annotated-cell-4-123" aria-hidden="true" tabindex="-1"></a>                wmma<span class="op">::</span>mma_sync<span class="op">(</span>accum_frag<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> a_frag<span class="op">,</span> b_frag<span class="op">,</span> accum_frag<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="annotated-cell-4-124"><a href="#annotated-cell-4-124" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="annotated-cell-4-125"><a href="#annotated-cell-4-125" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-4-126"><a href="#annotated-cell-4-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-127"><a href="#annotated-cell-4-127" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 3. WAIT for next tile</span></span>
<span id="annotated-cell-4-128"><a href="#annotated-cell-4-128" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">+</span> BLOCK_K <span class="op">&lt;</span> K<span class="op">)</span> <span class="op">{</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="9">9</button><span id="annotated-cell-4-129" class="code-annotation-target"><a href="#annotated-cell-4-129" aria-hidden="true" tabindex="-1"></a>            __pipeline_wait_prior<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="annotated-cell-4-130"><a href="#annotated-cell-4-130" aria-hidden="true" tabindex="-1"></a>            __syncthreads<span class="op">();</span></span>
<span id="annotated-cell-4-131"><a href="#annotated-cell-4-131" aria-hidden="true" tabindex="-1"></a>            stage <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> stage<span class="op">;</span></span>
<span id="annotated-cell-4-132"><a href="#annotated-cell-4-132" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-4-133"><a href="#annotated-cell-4-133" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-4-134"><a href="#annotated-cell-4-134" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------------------------------------</span></span>
<span id="annotated-cell-4-135"><a href="#annotated-cell-4-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-136"><a href="#annotated-cell-4-136" aria-hidden="true" tabindex="-1"></a>    __syncthreads<span class="op">();</span> <span class="co">// Since the syncthreads above won't execute on the last iteration</span></span>
<span id="annotated-cell-4-137"><a href="#annotated-cell-4-137" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="annotated-cell-4-138"><a href="#annotated-cell-4-138" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------- EPILOGUE: Store C ----------</span></span>
<span id="annotated-cell-4-139"><a href="#annotated-cell-4-139" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Size: 64 * 64 floats = 64 * 64 * 4 bytes = 16 KB. Fits easily in modern L1/Shared</span></span>
<span id="annotated-cell-4-140"><a href="#annotated-cell-4-140" aria-hidden="true" tabindex="-1"></a>    __shared__ <span class="dt">float</span> sC<span class="op">[</span>BLOCK_M <span class="op">*</span> BLOCK_N<span class="op">];</span></span>
<span id="annotated-cell-4-141"><a href="#annotated-cell-4-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-142"><a href="#annotated-cell-4-142" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Warps dump their fragments to shared memory, one 16x16 subtile at a time.</span></span>
<span id="annotated-cell-4-143"><a href="#annotated-cell-4-143" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-4-144"><a href="#annotated-cell-4-144" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-4-145"><a href="#annotated-cell-4-145" aria-hidden="true" tabindex="-1"></a>        <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-4-146"><a href="#annotated-cell-4-146" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-4-147"><a href="#annotated-cell-4-147" aria-hidden="true" tabindex="-1"></a>            <span class="dt">float</span><span class="op">*</span> subtile_ptr <span class="op">=</span> sC <span class="op">+</span> <span class="op">(</span>warp_row <span class="op">+</span> i <span class="op">*</span> <span class="dv">16</span><span class="op">)</span> <span class="op">*</span> BLOCK_N <span class="op">+</span> <span class="op">(</span>warp_col <span class="op">+</span> j <span class="op">*</span> <span class="dv">16</span><span class="op">);</span></span>
<span id="annotated-cell-4-148"><a href="#annotated-cell-4-148" aria-hidden="true" tabindex="-1"></a>            wmma<span class="op">::</span>store_matrix_sync<span class="op">(</span>subtile_ptr<span class="op">,</span> accum_frag<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> BLOCK_N<span class="op">,</span> wmma<span class="op">::</span>mem_row_major<span class="op">);</span></span>
<span id="annotated-cell-4-149"><a href="#annotated-cell-4-149" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-4-150"><a href="#annotated-cell-4-150" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-4-151"><a href="#annotated-cell-4-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-152"><a href="#annotated-cell-4-152" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Wait for all threads to write to sC</span></span>
<span id="annotated-cell-4-153"><a href="#annotated-cell-4-153" aria-hidden="true" tabindex="-1"></a>    __syncthreads<span class="op">();</span></span>
<span id="annotated-cell-4-154"><a href="#annotated-cell-4-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-155"><a href="#annotated-cell-4-155" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#pragma unroll</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="10">10</button><span id="annotated-cell-4-156" class="code-annotation-target"><a href="#annotated-cell-4-156" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> tid <span class="op">*</span> <span class="dv">8</span><span class="op">;</span> i <span class="op">&lt;</span> BLOCK_M <span class="op">*</span> BLOCK_N<span class="op">;</span> i <span class="op">+=</span> THREAD_COUNT <span class="op">*</span> <span class="dv">8</span><span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-4-157"><a href="#annotated-cell-4-157" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> row <span class="op">=</span> i <span class="op">/</span> BLOCK_N<span class="op">;</span></span>
<span id="annotated-cell-4-158"><a href="#annotated-cell-4-158" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> col <span class="op">=</span> i <span class="op">%</span> BLOCK_N<span class="op">;</span></span>
<span id="annotated-cell-4-159"><a href="#annotated-cell-4-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-160"><a href="#annotated-cell-4-160" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> global_row <span class="op">=</span> block_row_start <span class="op">+</span> row<span class="op">;</span></span>
<span id="annotated-cell-4-161"><a href="#annotated-cell-4-161" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> global_col <span class="op">=</span> block_col_start <span class="op">+</span> col<span class="op">;</span></span>
<span id="annotated-cell-4-162"><a href="#annotated-cell-4-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-163"><a href="#annotated-cell-4-163" aria-hidden="true" tabindex="-1"></a>        half buffer<span class="op">[</span><span class="dv">8</span><span class="op">];</span></span>
<span id="annotated-cell-4-164"><a href="#annotated-cell-4-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-165"><a href="#annotated-cell-4-165" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Boundary check</span></span>
<span id="annotated-cell-4-166"><a href="#annotated-cell-4-166" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>global_row <span class="op">&lt;</span> M <span class="op">&amp;&amp;</span> <span class="op">(</span>global_col <span class="op">+</span> <span class="dv">7</span><span class="op">)</span> <span class="op">&lt;</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-4-167"><a href="#annotated-cell-4-167" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-4-168"><a href="#annotated-cell-4-168" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">8</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-4-169"><a href="#annotated-cell-4-169" aria-hidden="true" tabindex="-1"></a>                <span class="dt">float</span> val <span class="op">=</span> alpha <span class="op">*</span> sC<span class="op">[</span>i <span class="op">+</span> j<span class="op">];</span></span>
<span id="annotated-cell-4-170"><a href="#annotated-cell-4-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-171"><a href="#annotated-cell-4-171" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>beta <span class="op">!=</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-4-172"><a href="#annotated-cell-4-172" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">float</span> old_c <span class="op">=</span> __half2float<span class="op">(</span>C<span class="op">[</span>global_row <span class="op">*</span> N <span class="op">+</span> global_col <span class="op">+</span> j<span class="op">]);</span></span>
<span id="annotated-cell-4-173"><a href="#annotated-cell-4-173" aria-hidden="true" tabindex="-1"></a>                    val <span class="op">+=</span> beta <span class="op">*</span> old_c<span class="op">;</span></span>
<span id="annotated-cell-4-174"><a href="#annotated-cell-4-174" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> </span>
<span id="annotated-cell-4-175"><a href="#annotated-cell-4-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-176"><a href="#annotated-cell-4-176" aria-hidden="true" tabindex="-1"></a>                buffer<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> __float2half<span class="op">(</span>val<span class="op">);</span></span>
<span id="annotated-cell-4-177"><a href="#annotated-cell-4-177" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="annotated-cell-4-178"><a href="#annotated-cell-4-178" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="annotated-cell-4-179"><a href="#annotated-cell-4-179" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Vectorized store</span></span>
<span id="annotated-cell-4-180"><a href="#annotated-cell-4-180" aria-hidden="true" tabindex="-1"></a>            <span class="op">*(</span>int4<span class="op">*)&amp;</span>C<span class="op">[</span>global_row <span class="op">*</span> N <span class="op">+</span> global_col<span class="op">]</span> <span class="op">=</span> <span class="op">*(</span>int4<span class="op">*)</span>buffer<span class="op">;</span></span>
<span id="annotated-cell-4-181"><a href="#annotated-cell-4-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-182"><a href="#annotated-cell-4-182" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="annotated-cell-4-183"><a href="#annotated-cell-4-183" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-4-184"><a href="#annotated-cell-4-184" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">8</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-4-185"><a href="#annotated-cell-4-185" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>global_row <span class="op">&lt;</span> M <span class="op">&amp;&amp;</span> <span class="op">(</span>global_col <span class="op">+</span> j<span class="op">)</span> <span class="op">&lt;</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-4-186"><a href="#annotated-cell-4-186" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">int</span> out_idx <span class="op">=</span> global_row <span class="op">*</span> N <span class="op">+</span> global_col <span class="op">+</span> j<span class="op">;</span></span>
<span id="annotated-cell-4-187"><a href="#annotated-cell-4-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-188"><a href="#annotated-cell-4-188" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">float</span> val <span class="op">=</span> alpha <span class="op">*</span> sC<span class="op">[</span>i <span class="op">+</span> j<span class="op">];</span></span>
<span id="annotated-cell-4-189"><a href="#annotated-cell-4-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-190"><a href="#annotated-cell-4-190" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="op">(</span>beta <span class="op">!=</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-4-191"><a href="#annotated-cell-4-191" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">float</span> old_c <span class="op">=</span> __half2float<span class="op">(</span>C<span class="op">[</span>out_idx<span class="op">]);</span></span>
<span id="annotated-cell-4-192"><a href="#annotated-cell-4-192" aria-hidden="true" tabindex="-1"></a>                        val <span class="op">+=</span> beta <span class="op">*</span> old_c<span class="op">;</span></span>
<span id="annotated-cell-4-193"><a href="#annotated-cell-4-193" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span> </span>
<span id="annotated-cell-4-194"><a href="#annotated-cell-4-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-195"><a href="#annotated-cell-4-195" aria-hidden="true" tabindex="-1"></a>                    C<span class="op">[</span>out_idx<span class="op">]</span> <span class="op">=</span> __float2half<span class="op">(</span>val<span class="op">);</span></span>
<span id="annotated-cell-4-196"><a href="#annotated-cell-4-196" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="annotated-cell-4-197"><a href="#annotated-cell-4-197" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="annotated-cell-4-198"><a href="#annotated-cell-4-198" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-4-199"><a href="#annotated-cell-4-199" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-4-200"><a href="#annotated-cell-4-200" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="annotated-cell-4-201"><a href="#annotated-cell-4-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-202"><a href="#annotated-cell-4-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-203"><a href="#annotated-cell-4-203" aria-hidden="true" tabindex="-1"></a><span class="co">// Same as in Tiled Matrix Multiplication</span></span>
<span id="annotated-cell-4-204"><a href="#annotated-cell-4-204" aria-hidden="true" tabindex="-1"></a>__global__ <span class="dt">void</span> gemm_tiled_kernel<span class="op">(</span><span class="at">const</span> half<span class="op">*</span> A<span class="op">,</span> <span class="at">const</span> half<span class="op">*</span> B<span class="op">,</span> half<span class="op">*</span> C<span class="op">,</span> <span class="dt">int</span> M<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> K<span class="op">,</span> <span class="dt">float</span> alpha<span class="op">,</span> <span class="dt">float</span> beta<span class="op">)</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="annotated-cell-4-205"><a href="#annotated-cell-4-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-206"><a href="#annotated-cell-4-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-207"><a href="#annotated-cell-4-207" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> <span class="st">"C"</span> <span class="dt">void</span> solve<span class="op">(</span><span class="at">const</span> half<span class="op">*</span> A<span class="op">,</span> <span class="at">const</span> half<span class="op">*</span> B<span class="op">,</span> half<span class="op">*</span> C<span class="op">,</span> <span class="dt">int</span> M<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> K<span class="op">,</span> <span class="dt">float</span> alpha<span class="op">,</span> <span class="dt">float</span> beta<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-4-208"><a href="#annotated-cell-4-208" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="annotated-cell-4-209"><a href="#annotated-cell-4-209" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>M <span class="op">%</span> <span class="dv">64</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> N <span class="op">%</span> <span class="dv">64</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> K <span class="op">%</span> <span class="dv">16</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-4-210"><a href="#annotated-cell-4-210" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="annotated-cell-4-211"><a href="#annotated-cell-4-211" aria-hidden="true" tabindex="-1"></a>        dim3 blockDim<span class="op">(</span>THREAD_COUNT<span class="op">);</span></span>
<span id="annotated-cell-4-212"><a href="#annotated-cell-4-212" aria-hidden="true" tabindex="-1"></a>        dim3 gridDim<span class="op">(</span>N <span class="op">/</span> BLOCK_N<span class="op">,</span> M <span class="op">/</span> BLOCK_M<span class="op">);</span></span>
<span id="annotated-cell-4-213"><a href="#annotated-cell-4-213" aria-hidden="true" tabindex="-1"></a>        gemm_buffer_kernel<span class="op">&lt;&lt;&lt;</span>gridDim<span class="op">,</span> blockDim<span class="op">&gt;&gt;&gt;(</span>A<span class="op">,</span> B<span class="op">,</span> C<span class="op">,</span> M<span class="op">,</span> N<span class="op">,</span> K<span class="op">,</span> alpha<span class="op">,</span> beta<span class="op">);</span></span>
<span id="annotated-cell-4-214"><a href="#annotated-cell-4-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-215"><a href="#annotated-cell-4-215" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="annotated-cell-4-216"><a href="#annotated-cell-4-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-217"><a href="#annotated-cell-4-217" aria-hidden="true" tabindex="-1"></a>        dim3 block<span class="op">(</span>TILE_WIDTH<span class="op">,</span> TILE_WIDTH<span class="op">);</span></span>
<span id="annotated-cell-4-218"><a href="#annotated-cell-4-218" aria-hidden="true" tabindex="-1"></a>        dim3 grid<span class="op">(</span></span>
<span id="annotated-cell-4-219"><a href="#annotated-cell-4-219" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span>N <span class="op">+</span> <span class="op">(</span>TILE_WIDTH <span class="op">*</span> COARSE_FACTOR<span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span>TILE_WIDTH <span class="op">*</span> COARSE_FACTOR<span class="op">),</span> </span>
<span id="annotated-cell-4-220"><a href="#annotated-cell-4-220" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span>M <span class="op">+</span> TILE_WIDTH <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> TILE_WIDTH</span>
<span id="annotated-cell-4-221"><a href="#annotated-cell-4-221" aria-hidden="true" tabindex="-1"></a>        <span class="op">);</span></span>
<span id="annotated-cell-4-222"><a href="#annotated-cell-4-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-223"><a href="#annotated-cell-4-223" aria-hidden="true" tabindex="-1"></a>        gemm_tiled_kernel<span class="op">&lt;&lt;&lt;</span>grid<span class="op">,</span> block<span class="op">&gt;&gt;&gt;(</span>A<span class="op">,</span> B<span class="op">,</span> C<span class="op">,</span> M<span class="op">,</span> N<span class="op">,</span> K<span class="op">,</span> alpha<span class="op">,</span> beta<span class="op">);</span></span>
<span id="annotated-cell-4-224"><a href="#annotated-cell-4-224" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-225"><a href="#annotated-cell-4-225" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-4-226"><a href="#annotated-cell-4-226" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-4" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="27" data-code-annotation="1"><strong>Warp Grid</strong>: As we have 128 threads per block, we have 4 warps per block, which we arrange in a 2x2 grid. Each block computes a 64 x 64 output tile, so we need to assign each warp a 32 x 32 output tile.</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="31" data-code-annotation="2"><strong>Data Loading</strong>: We treat the A and B tiles, 64 x 16 and 16 x 64 respectively, as linear arrays of 128 8-element vectors. So each thread is responsible for loading 8 halves to shared memory.</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="49" data-code-annotation="3"><strong>Accumulator Grid</strong>: Accumulator is a 2 x 2 grid because each warp is assigned a 32 x 32 output tile but can only compute 16 x 16 at a time.</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="74" data-code-annotation="4"><code>__pipeline_memcpy_async</code>: Instructs the Async Copy Engine to copy data from global memory to shared memory. As this is an asynchronous operation, the command returns immediately and allows us to continue with other instructions while the memory loads. We issue a vectorized load for 8 halves worth of data at once (<code>sizeof(int4)</code>).</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="77" data-code-annotation="5"><code>__pipeline_commit</code>: Marks the end of a batch of copy commands. Effectively, <code>memcpy_async</code> adds the copy instruction to our shopping cart, and <code>commit</code> places the order.</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="6">6</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="78" data-code-annotation="6"><code>__pipeline_wait_prior</code>: Since we pass in 0, we are pausing thread execution until all asynchronous loads that were issued are complete (in our case, only a single load). In any case, after this line, we have to issue <code>syncthreads</code> because each thread is collaboratively loading a piece of A and B that every thread will need for compute.</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="7">7</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="95" data-code-annotation="7"><strong>Writing to the Double Buffer</strong>: We load into the half of the double buffer that we’re not using this loop iterationn.</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="8">8</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="116" data-code-annotation="8"><strong>Reading from the Double Buffer</strong>: We pull data for the WMMA operation from the half of the double buffer that is ready.</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="9">9</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="129" data-code-annotation="9">Notice the location of this command in the main loop compared to in the prologue. We only had to issue it immediately after placing the copy command in the prologue because we needed to load the very first tile for compute. In the main loop, we don’t need to hold up threads on the copy completion until we have finished all compute for this iteration.</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="10">10</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="156" data-code-annotation="10"><strong>Vectorized Store</strong>: In this loop, we complete our GEMM operation by taking our accumulated result of A x B, scaling it by alpha, adding it to beta * C, and finally storing it in global memory. We have 64 * 64 = 4096 total elements to process and store, and 128 threads to do this. So we must process 32 elements per thread. If we vectorize this into processing 8 elements per step, we need only 4 steps per thread. However, we have an else block here that covers the tail elements once we have fewer than 8 elements left and can’t do a vectorized store.</span>
</dd>
</dl>
</section>
<section id="arithmetic-intensity-3" class="level3">
<h3 class="anchored" data-anchor-id="arithmetic-intensity-3">Arithmetic Intensity</h3>
<p>We will examine a single iteration of the main loop. We load in a 64 x 16 chunk of A and a 16 x 64 chunk of B from global memory, for a total of 2,048 halves, which is 4,096 bytes. Our output tile is 64 x 64, and on each loop iteration, we accumulate a dot product of two 16-element vectors to each pixel of the output tile. This dot product consists of 16 multiplications and 16 additions, so 32 FLOPs per pixel. In total then, we perform 64 * 64 * 32 = 131,072 FLOPs per loop iteration. Dividing this out by our global memory load of 4,096 bytes, we get an arithmetic intensity of 32 FLOPs/B. This is due to our increased tile size, not due to our double buffer which mainly helps with hiding memory latency. So we should theoretically have two different improvements that speed up our runtime: reusing more data due to the larger tile size, and latency hiding due to the double buffer. Thankfully, the runtime confirms this, as we can see considerable speedup on all GPUs.</p>
</section>
<section id="benchmarks-3" class="level3">
<h3 class="anchored" data-anchor-id="benchmarks-3">Benchmarks</h3>
<table class="table">
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">GPU Model</th>
<th style="text-align: left;">Memory Bandwidth</th>
<th style="text-align: left;">Peak FP16 Compute</th>
<th style="text-align: left;">Ridge Point (FLOP/Byte)</th>
<th style="text-align: left;">Runtime (ms)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>NVIDIA T4</strong></td>
<td style="text-align: left;">320 GB/s</td>
<td style="text-align: left;">65 TFLOPS</td>
<td style="text-align: left;">203</td>
<td style="text-align: left;">1.04</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>NVIDIA A100 (80GB)</strong></td>
<td style="text-align: left;">2,039 GB/s</td>
<td style="text-align: left;">312 TFLOPS</td>
<td style="text-align: left;">153</td>
<td style="text-align: left;">0.12</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>NVIDIA H100 (SXM)</strong></td>
<td style="text-align: left;">3,350 GB/s</td>
<td style="text-align: left;">989 TFLOPS</td>
<td style="text-align: left;">295</td>
<td style="text-align: left;">0.05</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>NVIDIA H200 (SXM)</strong></td>
<td style="text-align: left;">4,800 GB/s</td>
<td style="text-align: left;">989 TFLOPS</td>
<td style="text-align: left;">206</td>
<td style="text-align: left;">0.05</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>NVIDIA B200</strong></td>
<td style="text-align: left;">8,000 GB/s</td>
<td style="text-align: left;">2,500 TFLOPS</td>
<td style="text-align: left;">312</td>
<td style="text-align: left;">0.05</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="swizzling" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="swizzling">5. Swizzling</h2>
<p>So far, we’ve taken pretty good advantage of NVIDIA GPU architecture. Let’s go down the checklist:</p>
<ul class="task-list">
<li><label><input type="checkbox" checked="">Compute - We’re using the Tensor Cores to perform matrix multiplication and accumulation.</label></li>
<li><label><input type="checkbox" checked="">Registers - The Tensor Cores have their own dedicated registers to store data for the compute operation, so we’re not slowed down by loading data from shared memory for the operation.</label></li>
<li><label><input type="checkbox" checked="">Shared memory - We’re loading in large tiles from global memory at once per block and reusing as much data as possible between warps.</label></li>
<li><label><input type="checkbox" checked="">Memory latency hiding - With our double buffer, we’re ensuring we’re computing as much of the time as possible while we wait on memory to load.</label></li>
</ul>
<p>I haven’t yet discussed caches in detail. Take a look at the below diagram.</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="images/02_a100_memory.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption class="margin-caption">Memory hierarchy of an A100-40GB</figcaption>
</figure>
</div>
<p>There are two types of caches on the GPU: L1 and L2. A separate L1 cache exists on each Streaming Multiprocessor and is physically shared with Shared Memory, but not logically. We can control the split between shared memory and L1 if we so choose, but we can’t control what goes into L1 like we can for shared memory. L1 is a cache, so it’s hardware-managed and caches global memory accesses automatically. It handles some level of spatial and temporal locality automatically for us.</p>
<p>We discussed spatial locality briefly in the tiled GEMM section, but didn’t put a name to it. When we retrieve data from global memory, the GPU memory controller never fetches just a few bytes. It always fetches an aligned chunk of memory called a Cache Line, typically 128 bytes, which goes through and into the L1 cache. Ideally, all of the threads in a warp access contiguous memory addresses (i.e.&nbsp;Thread 0 reads address X, Thread 1 reads X + 4, etc). This is known as memory coalescing, and reduces the number of requests the memory controller needs to make to global memory, since we are using most or all of the full Cache Line retrieved every time, rather than just a fraction. Temporal locality means that the L1 will cache recently used data until its capacity is full and needs to evict old data. That way, in case we access the same data multiple times in a short period of time, we don’t need to retrieve it again from global memory as it is still in the cache.</p>
<p>The L2 cache functions in a similar way but is much larger and global to the whole GPU. As a tradeoff, it is also much slower to access for a thread than its local L1 cache. We already taking advantage of locality in our L1 cache in our previous kernels by ensuring threads in a warp are reading contiguous chunks of data. But we haven’t yet taken advantage of the L2 cache. The particular insight we need is that every block has access to the L2 cache. Ideally, we would figure out a way to establish some inter-block temporal locality: after one block accesses data from global memory, other blocks executing within a short time thereafter will reuse that data before it is evicted from the L2 cache.</p>
<p>Let’s think about what’s happening in our standard grid and tiling logic. Since we defined a 2D grid of blocks, and each block corresponds to a certain output tile in the matrix C, what’s happening is that we end up executing our blocks in a row-major order. Look at the first row of tiles in matrix C below.</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="images/03_tiled_mm.png" class="img-fluid figure-img" style="width:95.0%"></p>
<figcaption class="margin-caption">Visualization of tiled matrix multiplication</figcaption>
</figure>
</div>
<p>Imagine that our L2 cache can only fit 16 tiles. For each tile in that first row in C, we are repeatedly using the first row of tiles of A. However, we use a different column of B each time. By the time we’re on the fourth tile of C in the first row of tiles, we’re now loading in the fourth column of tiles of B, but we already have 16 tiles in our L2 cache (one row of tiles from A and three columns of tiles from B). So we have to evict some data to make room. We’ve been continuously reusing the first row of A, so that won’t be evicted; instead, we’ll evict the first column of B. But the next output tile we will compute for C after this one is the first tile in the second row, which would have reused the first column of B. Sadly, we just evicted it, so we’ll have to pull it from global memory again.</p>
<p>Instead, what we could do, given our L2 cache size, is split C into “newspaper columns”, each having a width of 2 tiles. We will adjust our block execution order so that we traverse the first newspaper column fully before we proceed to the second one. Now what happens? For the first two tiles of C, it’s the same logic as before. Our L2 cache now has the first row of A and first two columns of B. But now we hit the edge of our newspaper column, so we go down to the first tile in the second row of C. We load in the second row of A to the L2 cache, and now we have actually reached the cache capacity of 16 tiles. However, we are going to reuse the columns of B that are already in the L2 cache for the next two output tiles. Therefore, we loaded 16 tiles a single time from global memory and computed 4 output tiles. As opposed to before, we had to reload the needed column of B every time for the second row of output tiles of C, so we needed to load 20 tiles from global memory to compute 4 output tiles.</p>
<p>One way to think of this is that this is very similar to the rationale for tiled matrix multiplication. We are just adding another layer of tiling to the traversal. This block execution order is called grid swizzling and will allow us to get the most possible out of the L2 cache.</p>
<p>There is another memory bottleneck in our previous kernels that has to do with shared memory. To understand this bottleneck, we have to discuss the physical constraints of shared memory. Shared Memory is not a monolithic block of RAM. It is divided into physical banks. For the A100, Shared Memory in each SM is divided into 32 banks, each 4 bytes wide. These banks are effectively parallel lanes that the GPU can read from. The catch is that if we have multiple data requests to shared memory and these requests live in the same bank, then we have to serialize them. If the requests are each for memory in a different bank, then we can fully parallelize them.</p>
<p>Memory addresses are mapped to shared memory banks sequentially. So for 32 banks, we will have bytes 0-3 in Bank 0, 4-7 in Bank 1, …, 124-127 in Bank 31. And then bytes 128-131 wrap around and are placed in Bank 0 again. What we have been doing is defining a 2D array of shared memory that is exactly the size we need, such as a 64 x 64 array of shared memory to hold a 64 x 64 tile of half-precision float data. Since a half is 2 bytes, one row of this array consumes 128 bytes of shared memory. Therefore, when we access a row from this array, every element in that row will be in a different bank, so the request is highly parallelizable. But when we access a column from this array, it’s disastrous: every element in a column will be in the same bank! The request must be completely serialized.</p>
<p>The solution to this is shared memory swizzling: basically storing data to shared memory in a pattern that minimizes bank conflicts. In the below implementation, I use padding to add some dummy elements at the end of each row. In the above example, if we pad each row with 8 zeroes, then the start of the second row will be Bank 8, the start of the third row will be Bank 16, and so on. So we won’t run into extreme bank conflicts with column access. The disadvantage of this approach is that it does add a slight shared memory footprint, which can be an issue if we’re already using it heavily and near capacity. This isn’t the case for our kernel, but in production libraries the additional memory footprint is undesirable, so an approach called XOR swizzling is used instead. In XOR swizzling, the XOR operator is used (since it is computationally inexpensive) to permute the bank mapping of data based on its row and column. Modern libraries handle this swizzling for us, but since we are not using them as part of the problem constraints, I will stick with padding based swizzling for readability.</p>
<p>There is one more slight optimization included below. We double BLOCK_K to 32 and double our number of fragments for A and B. Doubling BLOCK_K means we load twice the data at the start of our K-loop and then have a new loop wrapping our warp math that executes exactly twice. The benefit is that we’re loading more data at once and have fewer total iterations in our K-loop as it increments by 32 rather than 16, so we have to issue the syncthreads and pipeline wait commands fewer times. Doubling the number of fragments means in our warp math loop, when a warp computes WMMA 4 times for its 2 x 2 grid of subtiles, we can load the necessary data into fragments all at once and then perform the MMA. Previously, we were loading into the same fragments 4 separate times.</p>
<section id="annotated-code-4" class="level3">
<h3 class="anchored" data-anchor-id="annotated-code-4">Annotated Code</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="annotated-cell-5"><pre class="sourceCode cpp code-annotation-code code-with-copy code-annotated"><code class="sourceCode cpp"><span id="annotated-cell-5-1"><a href="#annotated-cell-5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cuda_runtime.h&gt;</span></span>
<span id="annotated-cell-5-2"><a href="#annotated-cell-5-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cuda_fp16.h&gt;</span></span>
<span id="annotated-cell-5-3"><a href="#annotated-cell-5-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;mma.h&gt;</span></span>
<span id="annotated-cell-5-4"><a href="#annotated-cell-5-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cuda_pipeline_primitives.h&gt;</span></span>
<span id="annotated-cell-5-5"><a href="#annotated-cell-5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-6"><a href="#annotated-cell-5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> nvcuda<span class="op">;</span></span>
<span id="annotated-cell-5-7"><a href="#annotated-cell-5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-8"><a href="#annotated-cell-5-8" aria-hidden="true" tabindex="-1"></a><span class="co">// ------------- CONFIGURATION -------------</span></span>
<span id="annotated-cell-5-9"><a href="#annotated-cell-5-9" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> BLOCK_M <span class="op">=</span> <span class="dv">64</span><span class="op">;</span></span>
<span id="annotated-cell-5-10"><a href="#annotated-cell-5-10" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> BLOCK_N <span class="op">=</span> <span class="dv">64</span><span class="op">;</span> <span class="co">// One block computes a 64 x 64 tile of the output matrix</span></span>
<span id="annotated-cell-5-11"><a href="#annotated-cell-5-11" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> BLOCK_K <span class="op">=</span> <span class="dv">32</span><span class="op">;</span> <span class="co">// Accumulation step will be in terms of 16 but we load 32 at once to hide latency</span></span>
<span id="annotated-cell-5-12"><a href="#annotated-cell-5-12" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> WARP_SIZE <span class="op">=</span> <span class="dv">32</span><span class="op">;</span></span>
<span id="annotated-cell-5-13"><a href="#annotated-cell-5-13" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> THREAD_COUNT <span class="op">=</span> <span class="dv">128</span><span class="op">;</span></span>
<span id="annotated-cell-5-14"><a href="#annotated-cell-5-14" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> WMMA <span class="op">=</span> <span class="dv">16</span><span class="op">;</span></span>
<span id="annotated-cell-5-15"><a href="#annotated-cell-5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-16"><a href="#annotated-cell-5-16" aria-hidden="true" tabindex="-1"></a><span class="co">// Pad the row stride to avoid bank conflicts in shared memory.</span></span>
<span id="annotated-cell-5-17"><a href="#annotated-cell-5-17" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> SMEM_PAD <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="annotated-cell-5-18"><a href="#annotated-cell-5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-19"><a href="#annotated-cell-5-19" aria-hidden="true" tabindex="-1"></a>__global__ <span class="dt">void</span> gemm_swizzled_kernel<span class="op">(</span><span class="at">const</span> half<span class="op">*</span> A<span class="op">,</span> <span class="at">const</span> half<span class="op">*</span> B<span class="op">,</span> half<span class="op">*</span> C<span class="op">,</span> <span class="dt">int</span> M<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> K<span class="op">,</span> <span class="dt">float</span> alpha<span class="op">,</span> <span class="dt">float</span> beta<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-20"><a href="#annotated-cell-5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-21"><a href="#annotated-cell-5-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------------- GRID SWIZZLING (L2 Cache Optimization) -------------</span></span>
<span id="annotated-cell-5-22"><a href="#annotated-cell-5-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Remap the linear block index to a "Swizzled" 2D grid.</span></span>
<span id="annotated-cell-5-23"><a href="#annotated-cell-5-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-24"><a href="#annotated-cell-5-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Usually 2, 4, or 8</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-5" data-target-annotation="1">1</button><span id="annotated-cell-5-25" class="code-annotation-target"><a href="#annotated-cell-5-25" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> swizzle_factor <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="annotated-cell-5-26"><a href="#annotated-cell-5-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-27"><a href="#annotated-cell-5-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calculate linear block ID and grid dimensions</span></span>
<span id="annotated-cell-5-28"><a href="#annotated-cell-5-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> idx_linear <span class="op">=</span> blockIdx<span class="op">.</span>y <span class="op">*</span> gridDim<span class="op">.</span>x <span class="op">+</span> blockIdx<span class="op">.</span>x<span class="op">;</span></span>
<span id="annotated-cell-5-29"><a href="#annotated-cell-5-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> grid_m_blocks <span class="op">=</span> gridDim<span class="op">.</span>y<span class="op">;</span></span>
<span id="annotated-cell-5-30"><a href="#annotated-cell-5-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> grid_n_blocks <span class="op">=</span> gridDim<span class="op">.</span>x<span class="op">;</span></span>
<span id="annotated-cell-5-31"><a href="#annotated-cell-5-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-32"><a href="#annotated-cell-5-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Swizzle logic: Map linear ID to (block_row, block_col) in a localized pattern.</span></span>
<span id="annotated-cell-5-33"><a href="#annotated-cell-5-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This traverses the grid in 'thick columns' of width 'swizzle_factor'</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-5" data-target-annotation="2">2</button><span id="annotated-cell-5-34" class="code-annotation-target"><a href="#annotated-cell-5-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> panel_number <span class="op">=</span> idx_linear <span class="op">/</span> <span class="op">(</span>swizzle_factor <span class="op">*</span> grid_m_blocks<span class="op">);</span></span>
<span id="annotated-cell-5-35"><a href="#annotated-cell-5-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> block_row <span class="op">=</span> <span class="op">(</span>idx_linear <span class="op">/</span> swizzle_factor<span class="op">)</span> <span class="op">%</span> grid_m_blocks<span class="op">;</span></span>
<span id="annotated-cell-5-36"><a href="#annotated-cell-5-36" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> block_col <span class="op">=</span> <span class="op">(</span>idx_linear <span class="op">%</span> swizzle_factor<span class="op">)</span> <span class="op">+</span> panel_number <span class="op">*</span> swizzle_factor<span class="op">;</span></span>
<span id="annotated-cell-5-37"><a href="#annotated-cell-5-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="annotated-cell-5-38"><a href="#annotated-cell-5-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Safety check for irregular grids (if grid is not perfectly divisible)</span></span>
<span id="annotated-cell-5-39"><a href="#annotated-cell-5-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>block_row <span class="op">&gt;=</span> grid_m_blocks <span class="op">||</span> block_col <span class="op">&gt;=</span> grid_n_blocks<span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="annotated-cell-5-40"><a href="#annotated-cell-5-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-41"><a href="#annotated-cell-5-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calculate offsets based on swizzled coordinates</span></span>
<span id="annotated-cell-5-42"><a href="#annotated-cell-5-42" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> block_row_start <span class="op">=</span> block_row <span class="op">*</span> BLOCK_M<span class="op">;</span></span>
<span id="annotated-cell-5-43"><a href="#annotated-cell-5-43" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> block_col_start <span class="op">=</span> block_col <span class="op">*</span> BLOCK_N<span class="op">;</span></span>
<span id="annotated-cell-5-44"><a href="#annotated-cell-5-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">// --------------------------------------------------------------------</span></span>
<span id="annotated-cell-5-45"><a href="#annotated-cell-5-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-46"><a href="#annotated-cell-5-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="annotated-cell-5-47"><a href="#annotated-cell-5-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------------- INDEX CALCULATIONS -------------</span></span>
<span id="annotated-cell-5-48"><a href="#annotated-cell-5-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Linear view for data loading: which worker out of 128 threads am I?</span></span>
<span id="annotated-cell-5-49"><a href="#annotated-cell-5-49" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tid <span class="op">=</span> threadIdx<span class="op">.</span>x<span class="op">;</span></span>
<span id="annotated-cell-5-50"><a href="#annotated-cell-5-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-51"><a href="#annotated-cell-5-51" aria-hidden="true" tabindex="-1"></a>    <span class="co">// As we have 128 threads per block, we have 4 warps per block, which we arrange in a 2x2 grid.</span></span>
<span id="annotated-cell-5-52"><a href="#annotated-cell-5-52" aria-hidden="true" tabindex="-1"></a>    <span class="co">// As each block computes a 64 x 64 output tile, we need to assign each warp a 32 x 32 output tile.</span></span>
<span id="annotated-cell-5-53"><a href="#annotated-cell-5-53" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> warp_id <span class="op">=</span> tid <span class="op">/</span> WARP_SIZE<span class="op">;</span></span>
<span id="annotated-cell-5-54"><a href="#annotated-cell-5-54" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> warp_row <span class="op">=</span> <span class="op">(</span>warp_id <span class="op">/</span> <span class="dv">2</span><span class="op">)</span> <span class="op">*</span> <span class="dv">32</span><span class="op">;</span></span>
<span id="annotated-cell-5-55"><a href="#annotated-cell-5-55" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> warp_col <span class="op">=</span> <span class="op">(</span>warp_id <span class="op">%</span> <span class="dv">2</span><span class="op">)</span> <span class="op">*</span> <span class="dv">32</span><span class="op">;</span></span>
<span id="annotated-cell-5-56"><a href="#annotated-cell-5-56" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ----------------------------------------------</span></span>
<span id="annotated-cell-5-57"><a href="#annotated-cell-5-57" aria-hidden="true" tabindex="-1"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-5" data-target-annotation="3">3</button><span id="annotated-cell-5-58" class="code-annotation-target"><a href="#annotated-cell-5-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-59"><a href="#annotated-cell-5-59" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------------- MEMORY INITIALIZATION ----------</span></span>
<span id="annotated-cell-5-60"><a href="#annotated-cell-5-60" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Double Buffer: Shared Memory. Padded to remove bank conflicts </span></span>
<span id="annotated-cell-5-61"><a href="#annotated-cell-5-61" aria-hidden="true" tabindex="-1"></a>    __shared__ half sA<span class="op">[</span><span class="dv">2</span><span class="op">][</span>BLOCK_M <span class="op">*</span> <span class="op">(</span>BLOCK_K <span class="op">+</span> SMEM_PAD<span class="op">)];</span> <span class="co">// 64 rows, 40 cols (K + pad)</span></span>
<span id="annotated-cell-5-62"><a href="#annotated-cell-5-62" aria-hidden="true" tabindex="-1"></a>    __shared__ half sB<span class="op">[</span><span class="dv">2</span><span class="op">][</span>BLOCK_K <span class="op">*</span> <span class="op">(</span>BLOCK_N <span class="op">+</span> SMEM_PAD<span class="op">)];</span> <span class="co">// 40 rows (K + pad), 64 cols</span></span>
<span id="annotated-cell-5-63"><a href="#annotated-cell-5-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-64"><a href="#annotated-cell-5-64" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Declare fragments and initialize accumulator</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-5" data-target-annotation="4">4</button><span id="annotated-cell-5-65" class="code-annotation-target"><a href="#annotated-cell-5-65" aria-hidden="true" tabindex="-1"></a>    wmma<span class="op">::</span>fragment<span class="op">&lt;</span>wmma<span class="op">::</span>matrix_a<span class="op">,</span> WMMA<span class="op">,</span> WMMA<span class="op">,</span> WMMA<span class="op">,</span> half<span class="op">,</span> wmma<span class="op">::</span>row_major<span class="op">&gt;</span> a_frag<span class="op">[</span><span class="dv">2</span><span class="op">];</span></span>
<span id="annotated-cell-5-66"><a href="#annotated-cell-5-66" aria-hidden="true" tabindex="-1"></a>    wmma<span class="op">::</span>fragment<span class="op">&lt;</span>wmma<span class="op">::</span>matrix_b<span class="op">,</span> WMMA<span class="op">,</span> WMMA<span class="op">,</span> WMMA<span class="op">,</span> half<span class="op">,</span> wmma<span class="op">::</span>row_major<span class="op">&gt;</span> b_frag<span class="op">[</span><span class="dv">2</span><span class="op">];</span></span>
<span id="annotated-cell-5-67"><a href="#annotated-cell-5-67" aria-hidden="true" tabindex="-1"></a>    wmma<span class="op">::</span>fragment<span class="op">&lt;</span>wmma<span class="op">::</span>accumulator<span class="op">,</span> WMMA<span class="op">,</span> WMMA<span class="op">,</span> WMMA<span class="op">,</span> <span class="dt">float</span><span class="op">&gt;</span> accum_frag<span class="op">[</span><span class="dv">2</span><span class="op">][</span><span class="dv">2</span><span class="op">];</span></span>
<span id="annotated-cell-5-68"><a href="#annotated-cell-5-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-69"><a href="#annotated-cell-5-69" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-5-70"><a href="#annotated-cell-5-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-71"><a href="#annotated-cell-5-71" aria-hidden="true" tabindex="-1"></a>        <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-5-72"><a href="#annotated-cell-5-72" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-73"><a href="#annotated-cell-5-73" aria-hidden="true" tabindex="-1"></a>            wmma<span class="op">::</span>fill_fragment<span class="op">(</span>accum_frag<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">);</span></span>
<span id="annotated-cell-5-74"><a href="#annotated-cell-5-74" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-5-75"><a href="#annotated-cell-5-75" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-5-76"><a href="#annotated-cell-5-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-77"><a href="#annotated-cell-5-77" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Pipeline setup</span></span>
<span id="annotated-cell-5-78"><a href="#annotated-cell-5-78" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> stage <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Alternates between 0 and 1</span></span>
<span id="annotated-cell-5-79"><a href="#annotated-cell-5-79" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ----------------------------------------------</span></span>
<span id="annotated-cell-5-80"><a href="#annotated-cell-5-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-81"><a href="#annotated-cell-5-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-82"><a href="#annotated-cell-5-82" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------------- PROLOGUE -------------</span></span>
<span id="annotated-cell-5-83"><a href="#annotated-cell-5-83" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Load the first tile (k=0). A: 64x32. B: 32x64.</span></span>
<span id="annotated-cell-5-84"><a href="#annotated-cell-5-84" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We have 128 threads. We need to load 64*32 = 2048 halves per matrix.</span></span>
<span id="annotated-cell-5-85"><a href="#annotated-cell-5-85" aria-hidden="true" tabindex="-1"></a>    <span class="co">// So each thread must load 16 halves (int4 size) from each matrix.</span></span>
<span id="annotated-cell-5-86"><a href="#annotated-cell-5-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-87"><a href="#annotated-cell-5-87" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> half<span class="op">*</span> src_A_base <span class="op">=</span> A <span class="op">+</span> block_row_start <span class="op">*</span> K<span class="op">;</span></span>
<span id="annotated-cell-5-88"><a href="#annotated-cell-5-88" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> half<span class="op">*</span> src_B_base <span class="op">=</span> B <span class="op">+</span> block_col_start<span class="op">;</span></span>
<span id="annotated-cell-5-89"><a href="#annotated-cell-5-89" aria-hidden="true" tabindex="-1"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-5" data-target-annotation="5">5</button><span id="annotated-cell-5-90" class="code-annotation-target"><a href="#annotated-cell-5-90" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> load_tile_async <span class="op">=</span> <span class="op">[&amp;](</span><span class="dt">int</span> stage_idx<span class="op">,</span> <span class="dt">int</span> k_step<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-91"><a href="#annotated-cell-5-91" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> half<span class="op">*</span> A_ptr <span class="op">=</span> src_A_base <span class="op">+</span> k_step<span class="op">;</span> <span class="co">// Adding row * K is handled in loop</span></span>
<span id="annotated-cell-5-92"><a href="#annotated-cell-5-92" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> half<span class="op">*</span> B_ptr <span class="op">=</span> src_B_base <span class="op">+</span> k_step <span class="op">*</span> N<span class="op">;</span></span>
<span id="annotated-cell-5-93"><a href="#annotated-cell-5-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-94"><a href="#annotated-cell-5-94" aria-hidden="true" tabindex="-1"></a>        half<span class="op">*</span> sA_ptr <span class="op">=</span> sA<span class="op">[</span>stage_idx<span class="op">];</span></span>
<span id="annotated-cell-5-95"><a href="#annotated-cell-5-95" aria-hidden="true" tabindex="-1"></a>        half<span class="op">*</span> sB_ptr <span class="op">=</span> sB<span class="op">[</span>stage_idx<span class="op">];</span></span>
<span id="annotated-cell-5-96"><a href="#annotated-cell-5-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-97"><a href="#annotated-cell-5-97" aria-hidden="true" tabindex="-1"></a>        <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-5-98"><a href="#annotated-cell-5-98" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-99"><a href="#annotated-cell-5-99" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Calculate which vector of 8 halves this thread is moving</span></span>
<span id="annotated-cell-5-100"><a href="#annotated-cell-5-100" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> tid_offset <span class="op">=</span> tid <span class="op">+</span> i <span class="op">*</span> THREAD_COUNT<span class="op">;</span> <span class="co">// 0..127, then 128..255</span></span>
<span id="annotated-cell-5-101"><a href="#annotated-cell-5-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-102"><a href="#annotated-cell-5-102" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Map linear ID to (row, col) for A (64x32)</span></span>
<span id="annotated-cell-5-103"><a href="#annotated-cell-5-103" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Width is 32 (4 vectors of 8 halves).</span></span>
<span id="annotated-cell-5-104"><a href="#annotated-cell-5-104" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> vec_row_a <span class="op">=</span> tid_offset <span class="op">/</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="annotated-cell-5-105"><a href="#annotated-cell-5-105" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> vec_col_a <span class="op">=</span> <span class="op">(</span>tid_offset <span class="op">%</span> <span class="dv">4</span><span class="op">)</span> <span class="op">*</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="annotated-cell-5-106"><a href="#annotated-cell-5-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-107"><a href="#annotated-cell-5-107" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>vec_row_a <span class="op">&lt;</span> BLOCK_M<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-108"><a href="#annotated-cell-5-108" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Async Copy</span></span>
<span id="annotated-cell-5-109"><a href="#annotated-cell-5-109" aria-hidden="true" tabindex="-1"></a>                __pipeline_memcpy_async<span class="op">(</span></span>
<span id="annotated-cell-5-110"><a href="#annotated-cell-5-110" aria-hidden="true" tabindex="-1"></a>                    <span class="op">&amp;</span>sA_ptr<span class="op">[</span>vec_row_a <span class="op">*</span> <span class="op">(</span>BLOCK_K <span class="op">+</span> SMEM_PAD<span class="op">)</span> <span class="op">+</span> vec_col_a<span class="op">],</span> <span class="co">// Swizzled shared ptr</span></span>
<span id="annotated-cell-5-111"><a href="#annotated-cell-5-111" aria-hidden="true" tabindex="-1"></a>                    <span class="op">&amp;</span>A_ptr<span class="op">[</span>vec_row_a <span class="op">*</span> K <span class="op">+</span> vec_col_a<span class="op">],</span>                     <span class="co">// Global ptr</span></span>
<span id="annotated-cell-5-112"><a href="#annotated-cell-5-112" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">sizeof</span><span class="op">(</span>int4<span class="op">)</span></span>
<span id="annotated-cell-5-113"><a href="#annotated-cell-5-113" aria-hidden="true" tabindex="-1"></a>                <span class="op">);</span></span>
<span id="annotated-cell-5-114"><a href="#annotated-cell-5-114" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="annotated-cell-5-115"><a href="#annotated-cell-5-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-116"><a href="#annotated-cell-5-116" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Map linear ID to (row, col) for B (32x64)</span></span>
<span id="annotated-cell-5-117"><a href="#annotated-cell-5-117" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Width is 64 (8 vectors of 8 halves).</span></span>
<span id="annotated-cell-5-118"><a href="#annotated-cell-5-118" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> vec_row_b <span class="op">=</span> tid_offset <span class="op">/</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="annotated-cell-5-119"><a href="#annotated-cell-5-119" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> vec_col_b <span class="op">=</span> <span class="op">(</span>tid_offset <span class="op">%</span> <span class="dv">8</span><span class="op">)</span> <span class="op">*</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="annotated-cell-5-120"><a href="#annotated-cell-5-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-121"><a href="#annotated-cell-5-121" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>vec_row_b <span class="op">&lt;</span> BLOCK_K<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-122"><a href="#annotated-cell-5-122" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Async Copy</span></span>
<span id="annotated-cell-5-123"><a href="#annotated-cell-5-123" aria-hidden="true" tabindex="-1"></a>                __pipeline_memcpy_async<span class="op">(</span></span>
<span id="annotated-cell-5-124"><a href="#annotated-cell-5-124" aria-hidden="true" tabindex="-1"></a>                    <span class="op">&amp;</span>sB_ptr<span class="op">[</span>vec_row_b <span class="op">*</span> <span class="op">(</span>BLOCK_N <span class="op">+</span> SMEM_PAD<span class="op">)</span> <span class="op">+</span> vec_col_b<span class="op">],</span> <span class="co">// Swizzled shared ptr</span></span>
<span id="annotated-cell-5-125"><a href="#annotated-cell-5-125" aria-hidden="true" tabindex="-1"></a>                    <span class="op">&amp;</span>B_ptr<span class="op">[</span>vec_row_b <span class="op">*</span> N <span class="op">+</span> vec_col_b<span class="op">],</span>                     <span class="co">// Global ptr</span></span>
<span id="annotated-cell-5-126"><a href="#annotated-cell-5-126" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">sizeof</span><span class="op">(</span>int4<span class="op">)</span></span>
<span id="annotated-cell-5-127"><a href="#annotated-cell-5-127" aria-hidden="true" tabindex="-1"></a>                <span class="op">);</span></span>
<span id="annotated-cell-5-128"><a href="#annotated-cell-5-128" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="annotated-cell-5-129"><a href="#annotated-cell-5-129" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-5-130"><a href="#annotated-cell-5-130" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="annotated-cell-5-131"><a href="#annotated-cell-5-131" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="annotated-cell-5-132"><a href="#annotated-cell-5-132" aria-hidden="true" tabindex="-1"></a>    load_tile_async<span class="op">(</span>stage<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="annotated-cell-5-133"><a href="#annotated-cell-5-133" aria-hidden="true" tabindex="-1"></a>    __pipeline_commit<span class="op">();</span></span>
<span id="annotated-cell-5-134"><a href="#annotated-cell-5-134" aria-hidden="true" tabindex="-1"></a>    __pipeline_wait_prior<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="annotated-cell-5-135"><a href="#annotated-cell-5-135" aria-hidden="true" tabindex="-1"></a>    __syncthreads<span class="op">();</span></span>
<span id="annotated-cell-5-136"><a href="#annotated-cell-5-136" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------------------------------------</span></span>
<span id="annotated-cell-5-137"><a href="#annotated-cell-5-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-138"><a href="#annotated-cell-5-138" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------------- MAIN LOOP -------------</span></span>
<span id="annotated-cell-5-139"><a href="#annotated-cell-5-139" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> K<span class="op">;</span> k <span class="op">+=</span> BLOCK_K<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-140"><a href="#annotated-cell-5-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-141"><a href="#annotated-cell-5-141" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> k_next <span class="op">=</span> k <span class="op">+</span> BLOCK_K<span class="op">;</span></span>
<span id="annotated-cell-5-142"><a href="#annotated-cell-5-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-143"><a href="#annotated-cell-5-143" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 1. LOAD the next tile asynchronously</span></span>
<span id="annotated-cell-5-144"><a href="#annotated-cell-5-144" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k_next <span class="op">&lt;</span> K<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-145"><a href="#annotated-cell-5-145" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Turns 1 into 0 or 0 into 1</span></span>
<span id="annotated-cell-5-146"><a href="#annotated-cell-5-146" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> next_stage <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> stage<span class="op">;</span></span>
<span id="annotated-cell-5-147"><a href="#annotated-cell-5-147" aria-hidden="true" tabindex="-1"></a>            load_tile_async<span class="op">(</span>next_stage<span class="op">,</span> k_next<span class="op">);</span></span>
<span id="annotated-cell-5-148"><a href="#annotated-cell-5-148" aria-hidden="true" tabindex="-1"></a>            __pipeline_commit<span class="op">();</span></span>
<span id="annotated-cell-5-149"><a href="#annotated-cell-5-149" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-5-150"><a href="#annotated-cell-5-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-151"><a href="#annotated-cell-5-151" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 2. MATH: process the current tile. Recall we have a 2 x 2 grid of 16 x 16 subtiles for each warp.</span></span>
<span id="annotated-cell-5-152"><a href="#annotated-cell-5-152" aria-hidden="true" tabindex="-1"></a>        <span class="co">// BLOCK_K = 32, and WMMA accumulates 16x16x16 at a time, so we need to loop k_step 0..1.</span></span>
<span id="annotated-cell-5-153"><a href="#annotated-cell-5-153" aria-hidden="true" tabindex="-1"></a>        <span class="pp">#pragma unroll</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-5" data-target-annotation="6">6</button><span id="annotated-cell-5-154" class="code-annotation-target"><a href="#annotated-cell-5-154" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k_step <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k_step <span class="op">&lt;</span> BLOCK_K<span class="op">;</span> k_step <span class="op">+=</span> WMMA<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-155"><a href="#annotated-cell-5-155" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="annotated-cell-5-156"><a href="#annotated-cell-5-156" aria-hidden="true" tabindex="-1"></a>            <span class="co">// --- STEP A: Load Fragments into Registers (Pre-Load) ---</span></span>
<span id="annotated-cell-5-157"><a href="#annotated-cell-5-157" aria-hidden="true" tabindex="-1"></a>            <span class="co">// A Warp computes a 32 x 32 output tile.</span></span>
<span id="annotated-cell-5-158"><a href="#annotated-cell-5-158" aria-hidden="true" tabindex="-1"></a>            <span class="co">// This requires 32 rows of A (2 fragments) and 32 cols of B (2 fragments).</span></span>
<span id="annotated-cell-5-159"><a href="#annotated-cell-5-159" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="annotated-cell-5-160"><a href="#annotated-cell-5-160" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Load the 2 fragments of Matrix A needed for this warp</span></span>
<span id="annotated-cell-5-161"><a href="#annotated-cell-5-161" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-5-162"><a href="#annotated-cell-5-162" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-163"><a href="#annotated-cell-5-163" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> smem_row <span class="op">=</span> warp_row <span class="op">+</span> <span class="op">(</span>i <span class="op">*</span> <span class="dv">16</span><span class="op">);</span></span>
<span id="annotated-cell-5-164"><a href="#annotated-cell-5-164" aria-hidden="true" tabindex="-1"></a>                half<span class="op">*</span> tile_ptr_A <span class="op">=</span> <span class="op">&amp;</span>sA<span class="op">[</span>stage<span class="op">][</span>smem_row <span class="op">*</span> <span class="op">(</span>BLOCK_K <span class="op">+</span> SMEM_PAD<span class="op">)</span> <span class="op">+</span> k_step<span class="op">];</span></span>
<span id="annotated-cell-5-165"><a href="#annotated-cell-5-165" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="annotated-cell-5-166"><a href="#annotated-cell-5-166" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Load into specific index [i]</span></span>
<span id="annotated-cell-5-167"><a href="#annotated-cell-5-167" aria-hidden="true" tabindex="-1"></a>                wmma<span class="op">::</span>load_matrix_sync<span class="op">(</span>a_frag<span class="op">[</span>i<span class="op">],</span> tile_ptr_A<span class="op">,</span> BLOCK_K <span class="op">+</span> SMEM_PAD<span class="op">);</span></span>
<span id="annotated-cell-5-168"><a href="#annotated-cell-5-168" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="annotated-cell-5-169"><a href="#annotated-cell-5-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-170"><a href="#annotated-cell-5-170" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Load the 2 fragments of Matrix B needed for this warp</span></span>
<span id="annotated-cell-5-171"><a href="#annotated-cell-5-171" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-5-172"><a href="#annotated-cell-5-172" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-173"><a href="#annotated-cell-5-173" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> smem_col <span class="op">=</span> warp_col <span class="op">+</span> <span class="op">(</span>j <span class="op">*</span> <span class="dv">16</span><span class="op">);</span></span>
<span id="annotated-cell-5-174"><a href="#annotated-cell-5-174" aria-hidden="true" tabindex="-1"></a>                half<span class="op">*</span> tile_ptr_B <span class="op">=</span> <span class="op">&amp;</span>sB<span class="op">[</span>stage<span class="op">][</span>k_step <span class="op">*</span> <span class="op">(</span>BLOCK_N <span class="op">+</span> SMEM_PAD<span class="op">)</span> <span class="op">+</span> smem_col<span class="op">];</span></span>
<span id="annotated-cell-5-175"><a href="#annotated-cell-5-175" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="annotated-cell-5-176"><a href="#annotated-cell-5-176" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Load into specific index [j]</span></span>
<span id="annotated-cell-5-177"><a href="#annotated-cell-5-177" aria-hidden="true" tabindex="-1"></a>                wmma<span class="op">::</span>load_matrix_sync<span class="op">(</span>b_frag<span class="op">[</span>j<span class="op">],</span> tile_ptr_B<span class="op">,</span> BLOCK_N <span class="op">+</span> SMEM_PAD<span class="op">);</span></span>
<span id="annotated-cell-5-178"><a href="#annotated-cell-5-178" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="annotated-cell-5-179"><a href="#annotated-cell-5-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-180"><a href="#annotated-cell-5-180" aria-hidden="true" tabindex="-1"></a>            <span class="co">// --- STEP B: Compute (Reuse Registers) ---</span></span>
<span id="annotated-cell-5-181"><a href="#annotated-cell-5-181" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#pragma unroll</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-5" data-target-annotation="7">7</button><span id="annotated-cell-5-182" class="code-annotation-target"><a href="#annotated-cell-5-182" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-183"><a href="#annotated-cell-5-183" aria-hidden="true" tabindex="-1"></a>                <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-5-184"><a href="#annotated-cell-5-184" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-185"><a href="#annotated-cell-5-185" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// Reuse a_frag[i] and b_frag[j] multiple times</span></span>
<span id="annotated-cell-5-186"><a href="#annotated-cell-5-186" aria-hidden="true" tabindex="-1"></a>                    wmma<span class="op">::</span>mma_sync<span class="op">(</span>accum_frag<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> a_frag<span class="op">[</span>i<span class="op">],</span> b_frag<span class="op">[</span>j<span class="op">],</span> accum_frag<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="annotated-cell-5-187"><a href="#annotated-cell-5-187" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="annotated-cell-5-188"><a href="#annotated-cell-5-188" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="annotated-cell-5-189"><a href="#annotated-cell-5-189" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-5-190"><a href="#annotated-cell-5-190" aria-hidden="true" tabindex="-1"></a>       </span>
<span id="annotated-cell-5-191"><a href="#annotated-cell-5-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-192"><a href="#annotated-cell-5-192" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 3. WAIT for next tile</span></span>
<span id="annotated-cell-5-193"><a href="#annotated-cell-5-193" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">+</span> BLOCK_K <span class="op">&lt;</span> K<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-194"><a href="#annotated-cell-5-194" aria-hidden="true" tabindex="-1"></a>            __pipeline_wait_prior<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="annotated-cell-5-195"><a href="#annotated-cell-5-195" aria-hidden="true" tabindex="-1"></a>            __syncthreads<span class="op">();</span></span>
<span id="annotated-cell-5-196"><a href="#annotated-cell-5-196" aria-hidden="true" tabindex="-1"></a>            stage <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> stage<span class="op">;</span></span>
<span id="annotated-cell-5-197"><a href="#annotated-cell-5-197" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-5-198"><a href="#annotated-cell-5-198" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-5-199"><a href="#annotated-cell-5-199" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------------------------------------</span></span>
<span id="annotated-cell-5-200"><a href="#annotated-cell-5-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-201"><a href="#annotated-cell-5-201" aria-hidden="true" tabindex="-1"></a>    __syncthreads<span class="op">();</span> <span class="co">// Since the syncthreads above won't execute on the last iteration</span></span>
<span id="annotated-cell-5-202"><a href="#annotated-cell-5-202" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="annotated-cell-5-203"><a href="#annotated-cell-5-203" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------- EPILOGUE: Store C ----------</span></span>
<span id="annotated-cell-5-204"><a href="#annotated-cell-5-204" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We need a Shared Memory buffer for the floats from the Accumulators.</span></span>
<span id="annotated-cell-5-205"><a href="#annotated-cell-5-205" aria-hidden="true" tabindex="-1"></a>    __shared__ <span class="dt">float</span> sC<span class="op">[</span>BLOCK_M <span class="op">*</span> BLOCK_N<span class="op">];</span></span>
<span id="annotated-cell-5-206"><a href="#annotated-cell-5-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-207"><a href="#annotated-cell-5-207" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 1. Store Accumulators (Registers) -&gt; Shared Memory (Float)</span></span>
<span id="annotated-cell-5-208"><a href="#annotated-cell-5-208" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Each warp holds a 32x32 tile distributed across 2x2 fragments (16x16 each).</span></span>
<span id="annotated-cell-5-209"><a href="#annotated-cell-5-209" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-5-210"><a href="#annotated-cell-5-210" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-211"><a href="#annotated-cell-5-211" aria-hidden="true" tabindex="-1"></a>        <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-5-212"><a href="#annotated-cell-5-212" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-213"><a href="#annotated-cell-5-213" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Calculate where this 16x16 fragment belongs in the 64x64 block</span></span>
<span id="annotated-cell-5-214"><a href="#annotated-cell-5-214" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> row_offset <span class="op">=</span> warp_row <span class="op">+</span> <span class="op">(</span>i <span class="op">*</span> <span class="dv">16</span><span class="op">);</span></span>
<span id="annotated-cell-5-215"><a href="#annotated-cell-5-215" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> col_offset <span class="op">=</span> warp_col <span class="op">+</span> <span class="op">(</span>j <span class="op">*</span> <span class="dv">16</span><span class="op">);</span></span>
<span id="annotated-cell-5-216"><a href="#annotated-cell-5-216" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="annotated-cell-5-217"><a href="#annotated-cell-5-217" aria-hidden="true" tabindex="-1"></a>            <span class="dt">float</span><span class="op">*</span> smem_ptr <span class="op">=</span> sC <span class="op">+</span> row_offset <span class="op">*</span> BLOCK_N <span class="op">+</span> col_offset<span class="op">;</span></span>
<span id="annotated-cell-5-218"><a href="#annotated-cell-5-218" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-219"><a href="#annotated-cell-5-219" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Store fragment to shared memory (Stride is BLOCK_N)</span></span>
<span id="annotated-cell-5-220"><a href="#annotated-cell-5-220" aria-hidden="true" tabindex="-1"></a>            wmma<span class="op">::</span>store_matrix_sync<span class="op">(</span>smem_ptr<span class="op">,</span> accum_frag<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> BLOCK_N<span class="op">,</span> wmma<span class="op">::</span>mem_row_major<span class="op">);</span></span>
<span id="annotated-cell-5-221"><a href="#annotated-cell-5-221" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-5-222"><a href="#annotated-cell-5-222" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-5-223"><a href="#annotated-cell-5-223" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-224"><a href="#annotated-cell-5-224" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Wait for all warps to finish writing to sC</span></span>
<span id="annotated-cell-5-225"><a href="#annotated-cell-5-225" aria-hidden="true" tabindex="-1"></a>    __syncthreads<span class="op">();</span></span>
<span id="annotated-cell-5-226"><a href="#annotated-cell-5-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-227"><a href="#annotated-cell-5-227" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 2. Write Shared Memory (Float) -&gt; Global Memory (Half)</span></span>
<span id="annotated-cell-5-228"><a href="#annotated-cell-5-228" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Total Elements: 64 * 64 = 4096.</span></span>
<span id="annotated-cell-5-229"><a href="#annotated-cell-5-229" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Threads: 128.</span></span>
<span id="annotated-cell-5-230"><a href="#annotated-cell-5-230" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Elements per thread: 32.</span></span>
<span id="annotated-cell-5-231"><a href="#annotated-cell-5-231" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Vectors per thread: 32 / 8 = 4 vectors (int4).</span></span>
<span id="annotated-cell-5-232"><a href="#annotated-cell-5-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-233"><a href="#annotated-cell-5-233" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-5-234"><a href="#annotated-cell-5-234" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> v <span class="op">&lt;</span> <span class="dv">4</span><span class="op">;</span> v<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-235"><a href="#annotated-cell-5-235" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Calculate the linear index for this vector of 8 elements</span></span>
<span id="annotated-cell-5-236"><a href="#annotated-cell-5-236" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Stride by THREAD_COUNT to ensure coalescing (Thread 0 takes 0..7, Thread 1 takes 8..15)</span></span>
<span id="annotated-cell-5-237"><a href="#annotated-cell-5-237" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> vec_idx <span class="op">=</span> tid <span class="op">+</span> v <span class="op">*</span> THREAD_COUNT<span class="op">;</span> </span>
<span id="annotated-cell-5-238"><a href="#annotated-cell-5-238" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="annotated-cell-5-239"><a href="#annotated-cell-5-239" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> base_idx <span class="op">=</span> vec_idx <span class="op">*</span> <span class="dv">8</span><span class="op">;</span> <span class="co">// The starting element index</span></span>
<span id="annotated-cell-5-240"><a href="#annotated-cell-5-240" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> row <span class="op">=</span> base_idx <span class="op">/</span> BLOCK_N<span class="op">;</span></span>
<span id="annotated-cell-5-241"><a href="#annotated-cell-5-241" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> col <span class="op">=</span> base_idx <span class="op">%</span> BLOCK_N<span class="op">;</span></span>
<span id="annotated-cell-5-242"><a href="#annotated-cell-5-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-243"><a href="#annotated-cell-5-243" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> global_row <span class="op">=</span> block_row_start <span class="op">+</span> row<span class="op">;</span></span>
<span id="annotated-cell-5-244"><a href="#annotated-cell-5-244" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> global_col <span class="op">=</span> block_col_start <span class="op">+</span> col<span class="op">;</span></span>
<span id="annotated-cell-5-245"><a href="#annotated-cell-5-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-246"><a href="#annotated-cell-5-246" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Boundary Check (Safe for arbitrary M/N)</span></span>
<span id="annotated-cell-5-247"><a href="#annotated-cell-5-247" aria-hidden="true" tabindex="-1"></a>        <span class="co">// We check if the whole vector of 8 fits</span></span>
<span id="annotated-cell-5-248"><a href="#annotated-cell-5-248" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>global_row <span class="op">&lt;</span> M <span class="op">&amp;&amp;</span> global_col <span class="op">+</span> <span class="dv">7</span> <span class="op">&lt;</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-249"><a href="#annotated-cell-5-249" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="annotated-cell-5-250"><a href="#annotated-cell-5-250" aria-hidden="true" tabindex="-1"></a>            half out_buffer<span class="op">[</span><span class="dv">8</span><span class="op">];</span> <span class="co">// Register buffer for formatting</span></span>
<span id="annotated-cell-5-251"><a href="#annotated-cell-5-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-252"><a href="#annotated-cell-5-252" aria-hidden="true" tabindex="-1"></a>            <span class="co">// OPTIONAL: Beta Handling (Load old C)</span></span>
<span id="annotated-cell-5-253"><a href="#annotated-cell-5-253" aria-hidden="true" tabindex="-1"></a>            <span class="co">// If beta is non-zero, we must load the existing values from Global Memory first</span></span>
<span id="annotated-cell-5-254"><a href="#annotated-cell-5-254" aria-hidden="true" tabindex="-1"></a>            half old_c<span class="op">[</span><span class="dv">8</span><span class="op">];</span> </span>
<span id="annotated-cell-5-255"><a href="#annotated-cell-5-255" aria-hidden="true" tabindex="-1"></a>            <span class="dt">bool</span> use_beta <span class="op">=</span> <span class="op">(</span>beta <span class="op">!=</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">);</span></span>
<span id="annotated-cell-5-256"><a href="#annotated-cell-5-256" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-257"><a href="#annotated-cell-5-257" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>use_beta<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-258"><a href="#annotated-cell-5-258" aria-hidden="true" tabindex="-1"></a>                 <span class="co">// Vectorized Load of old C</span></span>
<span id="annotated-cell-5-259"><a href="#annotated-cell-5-259" aria-hidden="true" tabindex="-1"></a>                <span class="op">*(</span>int4<span class="op">*)</span>old_c <span class="op">=</span> <span class="op">*(</span>int4<span class="op">*)&amp;</span>C<span class="op">[</span>global_row <span class="op">*</span> N <span class="op">+</span> global_col<span class="op">];</span></span>
<span id="annotated-cell-5-260"><a href="#annotated-cell-5-260" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="annotated-cell-5-261"><a href="#annotated-cell-5-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-262"><a href="#annotated-cell-5-262" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Compute scaling and conversion</span></span>
<span id="annotated-cell-5-263"><a href="#annotated-cell-5-263" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-5-264"><a href="#annotated-cell-5-264" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> x <span class="op">&lt;</span> <span class="dv">8</span><span class="op">;</span> x<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-265"><a href="#annotated-cell-5-265" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Read float from Shared</span></span>
<span id="annotated-cell-5-266"><a href="#annotated-cell-5-266" aria-hidden="true" tabindex="-1"></a>                <span class="dt">float</span> val <span class="op">=</span> sC<span class="op">[</span>base_idx <span class="op">+</span> x<span class="op">];</span> </span>
<span id="annotated-cell-5-267"><a href="#annotated-cell-5-267" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="annotated-cell-5-268"><a href="#annotated-cell-5-268" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Apply Alpha</span></span>
<span id="annotated-cell-5-269"><a href="#annotated-cell-5-269" aria-hidden="true" tabindex="-1"></a>                val <span class="op">*=</span> alpha<span class="op">;</span></span>
<span id="annotated-cell-5-270"><a href="#annotated-cell-5-270" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-271"><a href="#annotated-cell-5-271" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Apply Beta</span></span>
<span id="annotated-cell-5-272"><a href="#annotated-cell-5-272" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>use_beta<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-273"><a href="#annotated-cell-5-273" aria-hidden="true" tabindex="-1"></a>                    val <span class="op">+=</span> beta <span class="op">*</span> __half2float<span class="op">(</span>old_c<span class="op">[</span>x<span class="op">]);</span></span>
<span id="annotated-cell-5-274"><a href="#annotated-cell-5-274" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="annotated-cell-5-275"><a href="#annotated-cell-5-275" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-276"><a href="#annotated-cell-5-276" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Convert to Half</span></span>
<span id="annotated-cell-5-277"><a href="#annotated-cell-5-277" aria-hidden="true" tabindex="-1"></a>                out_buffer<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> __float2half<span class="op">(</span>val<span class="op">);</span></span>
<span id="annotated-cell-5-278"><a href="#annotated-cell-5-278" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="annotated-cell-5-279"><a href="#annotated-cell-5-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-280"><a href="#annotated-cell-5-280" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Vectorized Store to Global Memory</span></span>
<span id="annotated-cell-5-281"><a href="#annotated-cell-5-281" aria-hidden="true" tabindex="-1"></a>            <span class="op">*(</span>int4<span class="op">*)&amp;</span>C<span class="op">[</span>global_row <span class="op">*</span> N <span class="op">+</span> global_col<span class="op">]</span> <span class="op">=</span> <span class="op">*(</span>int4<span class="op">*)</span>out_buffer<span class="op">;</span></span>
<span id="annotated-cell-5-282"><a href="#annotated-cell-5-282" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-283"><a href="#annotated-cell-5-283" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>global_row <span class="op">&lt;</span> M<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-284"><a href="#annotated-cell-5-284" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Edge Case: Partial vector write (at the edge of the matrix)</span></span>
<span id="annotated-cell-5-285"><a href="#annotated-cell-5-285" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> x <span class="op">&lt;</span> <span class="dv">8</span><span class="op">;</span> x<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-286"><a href="#annotated-cell-5-286" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>global_col <span class="op">+</span> x <span class="op">&lt;</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-287"><a href="#annotated-cell-5-287" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">float</span> val <span class="op">=</span> alpha <span class="op">*</span> sC<span class="op">[</span>base_idx <span class="op">+</span> x<span class="op">];</span></span>
<span id="annotated-cell-5-288"><a href="#annotated-cell-5-288" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="op">(</span>beta <span class="op">!=</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-289"><a href="#annotated-cell-5-289" aria-hidden="true" tabindex="-1"></a>                        val <span class="op">+=</span> beta <span class="op">*</span> __half2float<span class="op">(</span>C<span class="op">[</span>global_row <span class="op">*</span> N <span class="op">+</span> global_col <span class="op">+</span> x<span class="op">]);</span></span>
<span id="annotated-cell-5-290"><a href="#annotated-cell-5-290" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span></span>
<span id="annotated-cell-5-291"><a href="#annotated-cell-5-291" aria-hidden="true" tabindex="-1"></a>                    C<span class="op">[</span>global_row <span class="op">*</span> N <span class="op">+</span> global_col <span class="op">+</span> x<span class="op">]</span> <span class="op">=</span> __float2half<span class="op">(</span>val<span class="op">);</span></span>
<span id="annotated-cell-5-292"><a href="#annotated-cell-5-292" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="annotated-cell-5-293"><a href="#annotated-cell-5-293" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="annotated-cell-5-294"><a href="#annotated-cell-5-294" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-5-295"><a href="#annotated-cell-5-295" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> </span>
<span id="annotated-cell-5-296"><a href="#annotated-cell-5-296" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="annotated-cell-5-297"><a href="#annotated-cell-5-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-298"><a href="#annotated-cell-5-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-299"><a href="#annotated-cell-5-299" aria-hidden="true" tabindex="-1"></a><span class="co">// Same as before</span></span>
<span id="annotated-cell-5-300"><a href="#annotated-cell-5-300" aria-hidden="true" tabindex="-1"></a>__global__ <span class="dt">void</span> gemm_tiled_kernel<span class="op">(</span><span class="at">const</span> half<span class="op">*</span> A<span class="op">,</span> <span class="at">const</span> half<span class="op">*</span> B<span class="op">,</span> half<span class="op">*</span> C<span class="op">,</span> <span class="dt">int</span> M<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> K<span class="op">,</span> <span class="dt">float</span> alpha<span class="op">,</span> <span class="dt">float</span> beta<span class="op">)</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="annotated-cell-5-301"><a href="#annotated-cell-5-301" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-302"><a href="#annotated-cell-5-302" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> <span class="st">"C"</span> <span class="dt">void</span> solve<span class="op">(</span><span class="at">const</span> half<span class="op">*</span> A<span class="op">,</span> <span class="at">const</span> half<span class="op">*</span> B<span class="op">,</span> half<span class="op">*</span> C<span class="op">,</span> <span class="dt">int</span> M<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> K<span class="op">,</span> <span class="dt">float</span> alpha<span class="op">,</span> <span class="dt">float</span> beta<span class="op">)</span> <span class="op">{</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-5" data-target-annotation="8">8</button><span id="annotated-cell-5-303" class="code-annotation-target"><a href="#annotated-cell-5-303" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>M <span class="op">%</span> <span class="dv">64</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> N <span class="op">%</span> <span class="dv">64</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> K <span class="op">%</span> <span class="dv">32</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-5-304"><a href="#annotated-cell-5-304" aria-hidden="true" tabindex="-1"></a>        dim3 blockDim<span class="op">(</span>THREAD_COUNT<span class="op">);</span></span>
<span id="annotated-cell-5-305"><a href="#annotated-cell-5-305" aria-hidden="true" tabindex="-1"></a>        dim3 gridDim<span class="op">(</span>N <span class="op">/</span> BLOCK_N<span class="op">,</span> M <span class="op">/</span> BLOCK_M<span class="op">);</span></span>
<span id="annotated-cell-5-306"><a href="#annotated-cell-5-306" aria-hidden="true" tabindex="-1"></a>        gemm_swizzled_kernel<span class="op">&lt;&lt;&lt;</span>gridDim<span class="op">,</span> blockDim<span class="op">&gt;&gt;&gt;(</span>A<span class="op">,</span> B<span class="op">,</span> C<span class="op">,</span> M<span class="op">,</span> N<span class="op">,</span> K<span class="op">,</span> alpha<span class="op">,</span> beta<span class="op">);</span></span>
<span id="annotated-cell-5-307"><a href="#annotated-cell-5-307" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="annotated-cell-5-308"><a href="#annotated-cell-5-308" aria-hidden="true" tabindex="-1"></a>        dim3 blockDim<span class="op">(</span>TILE_WIDTH<span class="op">,</span> TILE_WIDTH<span class="op">);</span></span>
<span id="annotated-cell-5-309"><a href="#annotated-cell-5-309" aria-hidden="true" tabindex="-1"></a>        dim3 gridDim<span class="op">(</span></span>
<span id="annotated-cell-5-310"><a href="#annotated-cell-5-310" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span>N <span class="op">+</span> TILE_WIDTH <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> TILE_WIDTH<span class="op">,</span></span>
<span id="annotated-cell-5-311"><a href="#annotated-cell-5-311" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span>M <span class="op">+</span> TILE_WIDTH <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> TILE_WIDTH</span>
<span id="annotated-cell-5-312"><a href="#annotated-cell-5-312" aria-hidden="true" tabindex="-1"></a>        <span class="op">);</span></span>
<span id="annotated-cell-5-313"><a href="#annotated-cell-5-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-314"><a href="#annotated-cell-5-314" aria-hidden="true" tabindex="-1"></a>        gemm_tiled_kernel<span class="op">&lt;&lt;&lt;</span>gridDim<span class="op">,</span> blockDim<span class="op">&gt;&gt;&gt;(</span>A<span class="op">,</span> B<span class="op">,</span> C<span class="op">,</span> M<span class="op">,</span> N<span class="op">,</span> K<span class="op">,</span> alpha<span class="op">,</span> beta<span class="op">);</span></span>
<span id="annotated-cell-5-315"><a href="#annotated-cell-5-315" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-5-316"><a href="#annotated-cell-5-316" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-5" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-5" data-code-lines="25" data-code-annotation="1"><strong>Newspaper Panels</strong>: So our “newspaper panels” have a width of 4 blocks. This is a standard balanced choice: if we have too narrow of a panel, we are effectively traversing column-major, and if we have too wide of a panel, we might as well just traverse row-major.</span>
</dd>
<dt data-target-cell="annotated-cell-5" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-5" data-code-lines="34" data-code-annotation="2"><strong>Grid Swizzling</strong>: Computing the panel index beforehand tells us what column the left side of the current panel starts at. At the end of these few lines, we have our new block row and column index in terms of our output matrix, that traverses our newspaper columns first instead of going row-major.</span>
</dd>
<dt data-target-cell="annotated-cell-5" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-5" data-code-lines="58" data-code-annotation="3"><strong>Shared Memory Swizzling</strong>: This is where we swizzle the shared memory, by adding padding to our shared memory declaration.</span>
</dd>
<dt data-target-cell="annotated-cell-5" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-5" data-code-lines="65" data-code-annotation="4"><strong>Doubled Fragments</strong>: We double the number of fragments so we can load all the data at once the warp is using for its math loop into separate fragments, and then do all the math.</span>
</dd>
<dt data-target-cell="annotated-cell-5" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-5" data-code-lines="90" data-code-annotation="5"><strong>Async Loading Lambda</strong>: We moved the async loading to a lambda for readability.</span>
</dd>
<dt data-target-cell="annotated-cell-5" data-target-annotation="6">6</dt>
<dd>
<span data-code-cell="annotated-cell-5" data-code-lines="154" data-code-annotation="6"><strong>Doubled Data Loading</strong>: Since we’re loading twice the data now per K-loop iteration, we need a new k-step loop that performs the warp math twice.</span>
</dd>
<dt data-target-cell="annotated-cell-5" data-target-annotation="7">7</dt>
<dd>
<span data-code-cell="annotated-cell-5" data-code-lines="182" data-code-annotation="7"><strong>Warp Math</strong>: We load the data all at once before this into our 4 fragments, and then can just loop 4 times calling <code>mma_sync</code> to perform the math.</span>
</dd>
<dt data-target-cell="annotated-cell-5" data-target-annotation="8">8</dt>
<dd>
<span data-code-cell="annotated-cell-5" data-code-lines="303" data-code-annotation="8"><strong>Dimension Check</strong>: Since we doubled BLOCK_K we need to change this dimension check too. It may seem disappointing that we are now handling even fewer matrices with our optimized kernel. Don’t worry, we’ll fix this in the next kernel!</span>
</dd>
</dl>
</section>
<section id="arithmetic-intensity-4" class="level3">
<h3 class="anchored" data-anchor-id="arithmetic-intensity-4">Arithmetic Intensity</h3>
<p>The swizzling didn’t impact our actual FLOP count or memory volume. We did double BLOCK_K, but that effectively just doubled the number of FLOPs in our K-loop while also doubling the global memory load. So the arithmetic intensity is unchanged from our prior kernel: we’re still sitting at 32 FLOPs/B. Still, we witness considerable speedup from our optimizations.</p>
</section>
<section id="benchmarks-4" class="level3">
<h3 class="anchored" data-anchor-id="benchmarks-4">Benchmarks</h3>
<table class="table">
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">GPU Model</th>
<th style="text-align: left;">Memory Bandwidth</th>
<th style="text-align: left;">Peak FP16 Compute</th>
<th style="text-align: left;">Ridge Point (FLOP/Byte)</th>
<th style="text-align: left;">Runtime (ms)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>NVIDIA T4</strong></td>
<td style="text-align: left;">320 GB/s</td>
<td style="text-align: left;">65 TFLOPS</td>
<td style="text-align: left;">203</td>
<td style="text-align: left;">0.49</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>NVIDIA A100 (80GB)</strong></td>
<td style="text-align: left;">2,039 GB/s</td>
<td style="text-align: left;">312 TFLOPS</td>
<td style="text-align: left;">153</td>
<td style="text-align: left;">0.07</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>NVIDIA H100 (SXM)</strong></td>
<td style="text-align: left;">3,350 GB/s</td>
<td style="text-align: left;">989 TFLOPS</td>
<td style="text-align: left;">295</td>
<td style="text-align: left;">0.04</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>NVIDIA H200 (SXM)</strong></td>
<td style="text-align: left;">4,800 GB/s</td>
<td style="text-align: left;">989 TFLOPS</td>
<td style="text-align: left;">206</td>
<td style="text-align: left;">0.04</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>NVIDIA B200</strong></td>
<td style="text-align: left;">8,000 GB/s</td>
<td style="text-align: left;">2,500 TFLOPS</td>
<td style="text-align: left;">312</td>
<td style="text-align: left;">0.03</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="arbitrary-matrix-dimensions" class="level2">
<h2 class="anchored" data-anchor-id="arbitrary-matrix-dimensions">6. Arbitrary Matrix Dimensions</h2>
<p>It is unfortunate that we have made it this far without being able to fully remove our tiled GEMM kernel. This next kernel is a modification of the prior swizzled kernel that allows us to handle arbitrary dimensions in our input matrices. With some smart boundary checks and padding of shared memory with zeroes, we can ensure that we can use WMMA 16x16x16 operations across the entire matrix. We end up having some harmless padded zeroes as part of the operation that don’t impact the final result.</p>
<section id="annotated-code-5" class="level3">
<h3 class="anchored" data-anchor-id="annotated-code-5">Annotated Code</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="annotated-cell-6"><pre class="sourceCode cpp code-annotation-code code-with-copy code-annotated"><code class="sourceCode cpp"><span id="annotated-cell-6-1"><a href="#annotated-cell-6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cuda_runtime.h&gt;</span></span>
<span id="annotated-cell-6-2"><a href="#annotated-cell-6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cuda_fp16.h&gt;</span></span>
<span id="annotated-cell-6-3"><a href="#annotated-cell-6-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;mma.h&gt;</span></span>
<span id="annotated-cell-6-4"><a href="#annotated-cell-6-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cuda_pipeline_primitives.h&gt;</span></span>
<span id="annotated-cell-6-5"><a href="#annotated-cell-6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-6"><a href="#annotated-cell-6-6" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> nvcuda<span class="op">;</span></span>
<span id="annotated-cell-6-7"><a href="#annotated-cell-6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-8"><a href="#annotated-cell-6-8" aria-hidden="true" tabindex="-1"></a><span class="co">// ------------- CONFIGURATION -------------</span></span>
<span id="annotated-cell-6-9"><a href="#annotated-cell-6-9" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> BLOCK_M <span class="op">=</span> <span class="dv">64</span><span class="op">;</span></span>
<span id="annotated-cell-6-10"><a href="#annotated-cell-6-10" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> BLOCK_N <span class="op">=</span> <span class="dv">64</span><span class="op">;</span> <span class="co">// One block computes a 64 x 64 tile of the output matrix</span></span>
<span id="annotated-cell-6-11"><a href="#annotated-cell-6-11" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> BLOCK_K <span class="op">=</span> <span class="dv">32</span><span class="op">;</span> <span class="co">// Accumulation step will be in terms of 16 but we load 32 at once to hide latency</span></span>
<span id="annotated-cell-6-12"><a href="#annotated-cell-6-12" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> WARP_SIZE <span class="op">=</span> <span class="dv">32</span><span class="op">;</span></span>
<span id="annotated-cell-6-13"><a href="#annotated-cell-6-13" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> THREAD_COUNT <span class="op">=</span> <span class="dv">128</span><span class="op">;</span></span>
<span id="annotated-cell-6-14"><a href="#annotated-cell-6-14" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> WMMA <span class="op">=</span> <span class="dv">16</span><span class="op">;</span></span>
<span id="annotated-cell-6-15"><a href="#annotated-cell-6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-16"><a href="#annotated-cell-6-16" aria-hidden="true" tabindex="-1"></a><span class="co">// Pad to avoid bank conflicts in shared memory.</span></span>
<span id="annotated-cell-6-17"><a href="#annotated-cell-6-17" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> SMEM_PAD <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="annotated-cell-6-18"><a href="#annotated-cell-6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-19"><a href="#annotated-cell-6-19" aria-hidden="true" tabindex="-1"></a>__global__ <span class="dt">void</span> gemm_swizzled_all<span class="op">(</span><span class="at">const</span> half<span class="op">*</span> A<span class="op">,</span> <span class="at">const</span> half<span class="op">*</span> B<span class="op">,</span> half<span class="op">*</span> C<span class="op">,</span> <span class="dt">int</span> M<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> K<span class="op">,</span> <span class="dt">float</span> alpha<span class="op">,</span> <span class="dt">float</span> beta<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-20"><a href="#annotated-cell-6-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-21"><a href="#annotated-cell-6-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------------- GRID SWIZZLING (L2 Cache Optimization) -------------</span></span>
<span id="annotated-cell-6-22"><a href="#annotated-cell-6-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Remap the linear block index to a "Swizzled" 2D grid.</span></span>
<span id="annotated-cell-6-23"><a href="#annotated-cell-6-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-24"><a href="#annotated-cell-6-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Usually 2, 4, or 8</span></span>
<span id="annotated-cell-6-25"><a href="#annotated-cell-6-25" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> swizzle_factor <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="annotated-cell-6-26"><a href="#annotated-cell-6-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-27"><a href="#annotated-cell-6-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calculate linear block ID and grid dimensions</span></span>
<span id="annotated-cell-6-28"><a href="#annotated-cell-6-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> idx_linear <span class="op">=</span> blockIdx<span class="op">.</span>y <span class="op">*</span> gridDim<span class="op">.</span>x <span class="op">+</span> blockIdx<span class="op">.</span>x<span class="op">;</span></span>
<span id="annotated-cell-6-29"><a href="#annotated-cell-6-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> grid_m_blocks <span class="op">=</span> gridDim<span class="op">.</span>y<span class="op">;</span></span>
<span id="annotated-cell-6-30"><a href="#annotated-cell-6-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> grid_n_blocks <span class="op">=</span> gridDim<span class="op">.</span>x<span class="op">;</span></span>
<span id="annotated-cell-6-31"><a href="#annotated-cell-6-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-32"><a href="#annotated-cell-6-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Swizzle logic: Map linear ID to (block_row, block_col) in a localized pattern.</span></span>
<span id="annotated-cell-6-33"><a href="#annotated-cell-6-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This traverses the grid in 'thick columns' of width 'swizzle_factor'</span></span>
<span id="annotated-cell-6-34"><a href="#annotated-cell-6-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> panel_number <span class="op">=</span> idx_linear <span class="op">/</span> <span class="op">(</span>swizzle_factor <span class="op">*</span> grid_m_blocks<span class="op">);</span></span>
<span id="annotated-cell-6-35"><a href="#annotated-cell-6-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> block_row <span class="op">=</span> <span class="op">(</span>idx_linear <span class="op">/</span> swizzle_factor<span class="op">)</span> <span class="op">%</span> grid_m_blocks<span class="op">;</span></span>
<span id="annotated-cell-6-36"><a href="#annotated-cell-6-36" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> block_col <span class="op">=</span> <span class="op">(</span>idx_linear <span class="op">%</span> swizzle_factor<span class="op">)</span> <span class="op">+</span> panel_number <span class="op">*</span> swizzle_factor<span class="op">;</span></span>
<span id="annotated-cell-6-37"><a href="#annotated-cell-6-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="annotated-cell-6-38"><a href="#annotated-cell-6-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Safety check for irregular grids (if grid is not perfectly divisible)</span></span>
<span id="annotated-cell-6-39"><a href="#annotated-cell-6-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>block_row <span class="op">&gt;=</span> grid_m_blocks <span class="op">||</span> block_col <span class="op">&gt;=</span> grid_n_blocks<span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="annotated-cell-6-40"><a href="#annotated-cell-6-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-41"><a href="#annotated-cell-6-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calculate offsets based on swizzled coordinates</span></span>
<span id="annotated-cell-6-42"><a href="#annotated-cell-6-42" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> block_row_start <span class="op">=</span> block_row <span class="op">*</span> BLOCK_M<span class="op">;</span></span>
<span id="annotated-cell-6-43"><a href="#annotated-cell-6-43" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> block_col_start <span class="op">=</span> block_col <span class="op">*</span> BLOCK_N<span class="op">;</span></span>
<span id="annotated-cell-6-44"><a href="#annotated-cell-6-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">// --------------------------------------------------------------------</span></span>
<span id="annotated-cell-6-45"><a href="#annotated-cell-6-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-46"><a href="#annotated-cell-6-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="annotated-cell-6-47"><a href="#annotated-cell-6-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------------- INDEX CALCULATIONS -------------</span></span>
<span id="annotated-cell-6-48"><a href="#annotated-cell-6-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Linear view for data loading: which worker out of 128 threads am I?</span></span>
<span id="annotated-cell-6-49"><a href="#annotated-cell-6-49" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tid <span class="op">=</span> threadIdx<span class="op">.</span>x<span class="op">;</span></span>
<span id="annotated-cell-6-50"><a href="#annotated-cell-6-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-51"><a href="#annotated-cell-6-51" aria-hidden="true" tabindex="-1"></a>    <span class="co">// As we have 128 threads per block, we have 4 warps per block, which we arrange in a 2x2 grid.</span></span>
<span id="annotated-cell-6-52"><a href="#annotated-cell-6-52" aria-hidden="true" tabindex="-1"></a>    <span class="co">// As each block computes a 64 x 64 output tile, we need to assign each warp a 32 x 32 output tile.</span></span>
<span id="annotated-cell-6-53"><a href="#annotated-cell-6-53" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> warp_id <span class="op">=</span> tid <span class="op">/</span> WARP_SIZE<span class="op">;</span></span>
<span id="annotated-cell-6-54"><a href="#annotated-cell-6-54" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> warp_row <span class="op">=</span> <span class="op">(</span>warp_id <span class="op">/</span> <span class="dv">2</span><span class="op">)</span> <span class="op">*</span> <span class="dv">32</span><span class="op">;</span></span>
<span id="annotated-cell-6-55"><a href="#annotated-cell-6-55" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> warp_col <span class="op">=</span> <span class="op">(</span>warp_id <span class="op">%</span> <span class="dv">2</span><span class="op">)</span> <span class="op">*</span> <span class="dv">32</span><span class="op">;</span></span>
<span id="annotated-cell-6-56"><a href="#annotated-cell-6-56" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ----------------------------------------------</span></span>
<span id="annotated-cell-6-57"><a href="#annotated-cell-6-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-58"><a href="#annotated-cell-6-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-59"><a href="#annotated-cell-6-59" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------------- MEMORY INITIALIZATION ----------</span></span>
<span id="annotated-cell-6-60"><a href="#annotated-cell-6-60" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Double Buffer: Shared Memory. Padded to remove Bank Conflicts</span></span>
<span id="annotated-cell-6-61"><a href="#annotated-cell-6-61" aria-hidden="true" tabindex="-1"></a>    __shared__ half sA<span class="op">[</span><span class="dv">2</span><span class="op">][</span>BLOCK_M <span class="op">*</span> <span class="op">(</span>BLOCK_K <span class="op">+</span> SMEM_PAD<span class="op">)];</span> <span class="co">// 64 rows, 40 cols (K + pad)</span></span>
<span id="annotated-cell-6-62"><a href="#annotated-cell-6-62" aria-hidden="true" tabindex="-1"></a>    __shared__ half sB<span class="op">[</span><span class="dv">2</span><span class="op">][</span>BLOCK_K <span class="op">*</span> <span class="op">(</span>BLOCK_N <span class="op">+</span> SMEM_PAD<span class="op">)];</span> <span class="co">// 40 rows (K + pad), 64 cols</span></span>
<span id="annotated-cell-6-63"><a href="#annotated-cell-6-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-64"><a href="#annotated-cell-6-64" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Declare fragments and initialize accumulator</span></span>
<span id="annotated-cell-6-65"><a href="#annotated-cell-6-65" aria-hidden="true" tabindex="-1"></a>    wmma<span class="op">::</span>fragment<span class="op">&lt;</span>wmma<span class="op">::</span>matrix_a<span class="op">,</span> WMMA<span class="op">,</span> WMMA<span class="op">,</span> WMMA<span class="op">,</span> half<span class="op">,</span> wmma<span class="op">::</span>row_major<span class="op">&gt;</span> a_frag<span class="op">[</span><span class="dv">2</span><span class="op">];</span> <span class="co">// x2 for K=32</span></span>
<span id="annotated-cell-6-66"><a href="#annotated-cell-6-66" aria-hidden="true" tabindex="-1"></a>    wmma<span class="op">::</span>fragment<span class="op">&lt;</span>wmma<span class="op">::</span>matrix_b<span class="op">,</span> WMMA<span class="op">,</span> WMMA<span class="op">,</span> WMMA<span class="op">,</span> half<span class="op">,</span> wmma<span class="op">::</span>row_major<span class="op">&gt;</span> b_frag<span class="op">[</span><span class="dv">2</span><span class="op">];</span></span>
<span id="annotated-cell-6-67"><a href="#annotated-cell-6-67" aria-hidden="true" tabindex="-1"></a>    wmma<span class="op">::</span>fragment<span class="op">&lt;</span>wmma<span class="op">::</span>accumulator<span class="op">,</span> WMMA<span class="op">,</span> WMMA<span class="op">,</span> WMMA<span class="op">,</span> <span class="dt">float</span><span class="op">&gt;</span> accum_frag<span class="op">[</span><span class="dv">2</span><span class="op">][</span><span class="dv">2</span><span class="op">];</span></span>
<span id="annotated-cell-6-68"><a href="#annotated-cell-6-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-69"><a href="#annotated-cell-6-69" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-6-70"><a href="#annotated-cell-6-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-71"><a href="#annotated-cell-6-71" aria-hidden="true" tabindex="-1"></a>        <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-6-72"><a href="#annotated-cell-6-72" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-73"><a href="#annotated-cell-6-73" aria-hidden="true" tabindex="-1"></a>            wmma<span class="op">::</span>fill_fragment<span class="op">(</span>accum_frag<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">);</span></span>
<span id="annotated-cell-6-74"><a href="#annotated-cell-6-74" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-6-75"><a href="#annotated-cell-6-75" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-6-76"><a href="#annotated-cell-6-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-77"><a href="#annotated-cell-6-77" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Pipeline setup</span></span>
<span id="annotated-cell-6-78"><a href="#annotated-cell-6-78" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> stage <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Alternates between 0 and 1</span></span>
<span id="annotated-cell-6-79"><a href="#annotated-cell-6-79" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ----------------------------------------------</span></span>
<span id="annotated-cell-6-80"><a href="#annotated-cell-6-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-81"><a href="#annotated-cell-6-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-82"><a href="#annotated-cell-6-82" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------------- PROLOGUE -------------</span></span>
<span id="annotated-cell-6-83"><a href="#annotated-cell-6-83" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Load the first tile (k=0). A: 64x32. B: 32x64.</span></span>
<span id="annotated-cell-6-84"><a href="#annotated-cell-6-84" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We have 128 threads. We need to load 64*32 = 2048 halves per matrix.</span></span>
<span id="annotated-cell-6-85"><a href="#annotated-cell-6-85" aria-hidden="true" tabindex="-1"></a>    <span class="co">// So each thread must load 16 halves (int4 size) from each matrix.</span></span>
<span id="annotated-cell-6-86"><a href="#annotated-cell-6-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-87"><a href="#annotated-cell-6-87" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> half<span class="op">*</span> src_A_base <span class="op">=</span> A <span class="op">+</span> block_row_start <span class="op">*</span> K<span class="op">;</span></span>
<span id="annotated-cell-6-88"><a href="#annotated-cell-6-88" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> half<span class="op">*</span> src_B_base <span class="op">=</span> B <span class="op">+</span> block_col_start<span class="op">;</span></span>
<span id="annotated-cell-6-89"><a href="#annotated-cell-6-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-90"><a href="#annotated-cell-6-90" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> load_tile_async <span class="op">=</span> <span class="op">[&amp;](</span><span class="dt">int</span> stage_idx<span class="op">,</span> <span class="dt">int</span> k_step<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-91"><a href="#annotated-cell-6-91" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> half<span class="op">*</span> A_ptr <span class="op">=</span> src_A_base <span class="op">+</span> k_step<span class="op">;</span> <span class="co">// Base pointer for this tile</span></span>
<span id="annotated-cell-6-92"><a href="#annotated-cell-6-92" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> half<span class="op">*</span> B_ptr <span class="op">=</span> src_B_base <span class="op">+</span> k_step <span class="op">*</span> N<span class="op">;</span> </span>
<span id="annotated-cell-6-93"><a href="#annotated-cell-6-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-94"><a href="#annotated-cell-6-94" aria-hidden="true" tabindex="-1"></a>        half<span class="op">*</span> sA_ptr <span class="op">=</span> sA<span class="op">[</span>stage_idx<span class="op">];</span></span>
<span id="annotated-cell-6-95"><a href="#annotated-cell-6-95" aria-hidden="true" tabindex="-1"></a>        half<span class="op">*</span> sB_ptr <span class="op">=</span> sB<span class="op">[</span>stage_idx<span class="op">];</span></span>
<span id="annotated-cell-6-96"><a href="#annotated-cell-6-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-97"><a href="#annotated-cell-6-97" aria-hidden="true" tabindex="-1"></a>        <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-6-98"><a href="#annotated-cell-6-98" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-99"><a href="#annotated-cell-6-99" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> tid_offset <span class="op">=</span> tid <span class="op">+</span> i <span class="op">*</span> THREAD_COUNT<span class="op">;</span></span>
<span id="annotated-cell-6-100"><a href="#annotated-cell-6-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-101"><a href="#annotated-cell-6-101" aria-hidden="true" tabindex="-1"></a>            <span class="co">// --- LOAD MATRIX A (Row-Major: [M x K]) ---</span></span>
<span id="annotated-cell-6-102"><a href="#annotated-cell-6-102" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> vec_row_a <span class="op">=</span> tid_offset <span class="op">/</span> <span class="dv">4</span><span class="op">;</span>        <span class="co">// Local Row (0..63)</span></span>
<span id="annotated-cell-6-103"><a href="#annotated-cell-6-103" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> vec_col_a <span class="op">=</span> <span class="op">(</span>tid_offset <span class="op">%</span> <span class="dv">4</span><span class="op">)</span> <span class="op">*</span> <span class="dv">8</span><span class="op">;</span>  <span class="co">// Local Col (0, 8, 16, 24)</span></span>
<span id="annotated-cell-6-104"><a href="#annotated-cell-6-104" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="annotated-cell-6-105"><a href="#annotated-cell-6-105" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> global_row_a <span class="op">=</span> block_row_start <span class="op">+</span> vec_row_a<span class="op">;</span></span>
<span id="annotated-cell-6-106"><a href="#annotated-cell-6-106" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> global_col_a <span class="op">=</span> k_step <span class="op">+</span> vec_col_a<span class="op">;</span></span>
<span id="annotated-cell-6-107"><a href="#annotated-cell-6-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-108"><a href="#annotated-cell-6-108" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Address of the shared memory destination</span></span>
<span id="annotated-cell-6-109"><a href="#annotated-cell-6-109" aria-hidden="true" tabindex="-1"></a>            half<span class="op">*</span> dst_a <span class="op">=</span> <span class="op">&amp;</span>sA_ptr<span class="op">[</span>vec_row_a <span class="op">*</span> <span class="op">(</span>BLOCK_K <span class="op">+</span> SMEM_PAD<span class="op">)</span> <span class="op">+</span> vec_col_a<span class="op">];</span></span>
<span id="annotated-cell-6-110"><a href="#annotated-cell-6-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-111"><a href="#annotated-cell-6-111" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 1. Check strict bounds (Is this whole vector inside the matrix?)</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-6" data-target-annotation="1">1</button><span id="annotated-cell-6-112" class="code-annotation-target"><a href="#annotated-cell-6-112" aria-hidden="true" tabindex="-1"></a>            <span class="dt">bool</span> a_fully_valid <span class="op">=</span> <span class="op">(</span>global_row_a <span class="op">&lt;</span> M<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>global_col_a <span class="op">+</span> <span class="dv">7</span> <span class="op">&lt;</span> K<span class="op">);</span></span>
<span id="annotated-cell-6-113"><a href="#annotated-cell-6-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-114"><a href="#annotated-cell-6-114" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>a_fully_valid<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-115"><a href="#annotated-cell-6-115" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Fast path: Async Copy</span></span>
<span id="annotated-cell-6-116"><a href="#annotated-cell-6-116" aria-hidden="true" tabindex="-1"></a>                 __pipeline_memcpy_async<span class="op">(</span>dst_a<span class="op">,</span> <span class="op">&amp;</span>A_ptr<span class="op">[</span>vec_row_a <span class="op">*</span> K <span class="op">+</span> vec_col_a<span class="op">],</span> <span class="kw">sizeof</span><span class="op">(</span>int4<span class="op">));</span></span>
<span id="annotated-cell-6-117"><a href="#annotated-cell-6-117" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> </span>
<span id="annotated-cell-6-118"><a href="#annotated-cell-6-118" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="op">{</span></span>
<span id="annotated-cell-6-119"><a href="#annotated-cell-6-119" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Slow / Edge path: Manual loading or Zeroing</span></span>
<span id="annotated-cell-6-120"><a href="#annotated-cell-6-120" aria-hidden="true" tabindex="-1"></a>                <span class="co">// We must ensure Shared Memory has 0s where the matrix has nothing</span></span>
<span id="annotated-cell-6-121"><a href="#annotated-cell-6-121" aria-hidden="true" tabindex="-1"></a>                <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-6-122"><a href="#annotated-cell-6-122" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> v<span class="op">=</span><span class="dv">0</span><span class="op">;</span> v<span class="op">&lt;</span><span class="dv">8</span><span class="op">;</span> v<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-123"><a href="#annotated-cell-6-123" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="op">(</span>global_row_a <span class="op">&lt;</span> M <span class="op">&amp;&amp;</span> <span class="op">(</span>global_col_a <span class="op">+</span> v<span class="op">)</span> <span class="op">&lt;</span> K<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-124"><a href="#annotated-cell-6-124" aria-hidden="true" tabindex="-1"></a>                        dst_a<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> A_ptr<span class="op">[</span>vec_row_a <span class="op">*</span> K <span class="op">+</span> <span class="op">(</span>vec_col_a <span class="op">+</span> v<span class="op">)];</span></span>
<span id="annotated-cell-6-125"><a href="#annotated-cell-6-125" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="annotated-cell-6-126"><a href="#annotated-cell-6-126" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// Pad with zeroes</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-6" data-target-annotation="2">2</button><span id="annotated-cell-6-127" class="code-annotation-target"><a href="#annotated-cell-6-127" aria-hidden="true" tabindex="-1"></a>                        dst_a<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> __float2half<span class="op">(</span><span class="fl">0.0</span><span class="bu">f</span><span class="op">);</span></span>
<span id="annotated-cell-6-128"><a href="#annotated-cell-6-128" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span></span>
<span id="annotated-cell-6-129"><a href="#annotated-cell-6-129" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="annotated-cell-6-130"><a href="#annotated-cell-6-130" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="annotated-cell-6-131"><a href="#annotated-cell-6-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-132"><a href="#annotated-cell-6-132" aria-hidden="true" tabindex="-1"></a>            <span class="co">// --- LOAD MATRIX B (Row-Major: [K x N]) ---</span></span>
<span id="annotated-cell-6-133"><a href="#annotated-cell-6-133" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> vec_row_b <span class="op">=</span> tid_offset <span class="op">/</span> <span class="dv">8</span><span class="op">;</span>        <span class="co">// Local Row (0..31)</span></span>
<span id="annotated-cell-6-134"><a href="#annotated-cell-6-134" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> vec_col_b <span class="op">=</span> <span class="op">(</span>tid_offset <span class="op">%</span> <span class="dv">8</span><span class="op">)</span> <span class="op">*</span> <span class="dv">8</span><span class="op">;</span>  <span class="co">// Local Col (0..56)</span></span>
<span id="annotated-cell-6-135"><a href="#annotated-cell-6-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-136"><a href="#annotated-cell-6-136" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> global_row_b <span class="op">=</span> k_step <span class="op">+</span> vec_row_b<span class="op">;</span></span>
<span id="annotated-cell-6-137"><a href="#annotated-cell-6-137" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> global_col_b <span class="op">=</span> block_col_start <span class="op">+</span> vec_col_b<span class="op">;</span></span>
<span id="annotated-cell-6-138"><a href="#annotated-cell-6-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-139"><a href="#annotated-cell-6-139" aria-hidden="true" tabindex="-1"></a>            half<span class="op">*</span> dst_b <span class="op">=</span> <span class="op">&amp;</span>sB_ptr<span class="op">[</span>vec_row_b <span class="op">*</span> <span class="op">(</span>BLOCK_N <span class="op">+</span> SMEM_PAD<span class="op">)</span> <span class="op">+</span> vec_col_b<span class="op">];</span></span>
<span id="annotated-cell-6-140"><a href="#annotated-cell-6-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-141"><a href="#annotated-cell-6-141" aria-hidden="true" tabindex="-1"></a>            <span class="dt">bool</span> b_fully_valid <span class="op">=</span> <span class="op">(</span>global_row_b <span class="op">&lt;</span> K<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>global_col_b <span class="op">+</span> <span class="dv">7</span> <span class="op">&lt;</span> N<span class="op">);</span></span>
<span id="annotated-cell-6-142"><a href="#annotated-cell-6-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-143"><a href="#annotated-cell-6-143" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>b_fully_valid<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-144"><a href="#annotated-cell-6-144" aria-hidden="true" tabindex="-1"></a>                 __pipeline_memcpy_async<span class="op">(</span>dst_b<span class="op">,</span> <span class="op">&amp;</span>B_ptr<span class="op">[</span>vec_row_b <span class="op">*</span> N <span class="op">+</span> vec_col_b<span class="op">],</span> <span class="kw">sizeof</span><span class="op">(</span>int4<span class="op">));</span></span>
<span id="annotated-cell-6-145"><a href="#annotated-cell-6-145" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="annotated-cell-6-146"><a href="#annotated-cell-6-146" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Edge path</span></span>
<span id="annotated-cell-6-147"><a href="#annotated-cell-6-147" aria-hidden="true" tabindex="-1"></a>                <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-6-148"><a href="#annotated-cell-6-148" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> v<span class="op">=</span><span class="dv">0</span><span class="op">;</span> v<span class="op">&lt;</span><span class="dv">8</span><span class="op">;</span> v<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-149"><a href="#annotated-cell-6-149" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="op">(</span>global_row_b <span class="op">&lt;</span> K <span class="op">&amp;&amp;</span> <span class="op">(</span>global_col_b <span class="op">+</span> v<span class="op">)</span> <span class="op">&lt;</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-150"><a href="#annotated-cell-6-150" aria-hidden="true" tabindex="-1"></a>                        dst_b<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> B_ptr<span class="op">[</span>vec_row_b <span class="op">*</span> N <span class="op">+</span> <span class="op">(</span>vec_col_b <span class="op">+</span> v<span class="op">)];</span></span>
<span id="annotated-cell-6-151"><a href="#annotated-cell-6-151" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="annotated-cell-6-152"><a href="#annotated-cell-6-152" aria-hidden="true" tabindex="-1"></a>                        dst_b<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> __float2half<span class="op">(</span><span class="fl">0.0</span><span class="bu">f</span><span class="op">);</span> <span class="co">// PAD WITH ZERO</span></span>
<span id="annotated-cell-6-153"><a href="#annotated-cell-6-153" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span></span>
<span id="annotated-cell-6-154"><a href="#annotated-cell-6-154" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="annotated-cell-6-155"><a href="#annotated-cell-6-155" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="annotated-cell-6-156"><a href="#annotated-cell-6-156" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-6-157"><a href="#annotated-cell-6-157" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="annotated-cell-6-158"><a href="#annotated-cell-6-158" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="annotated-cell-6-159"><a href="#annotated-cell-6-159" aria-hidden="true" tabindex="-1"></a>    load_tile_async<span class="op">(</span>stage<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="annotated-cell-6-160"><a href="#annotated-cell-6-160" aria-hidden="true" tabindex="-1"></a>    __pipeline_commit<span class="op">();</span></span>
<span id="annotated-cell-6-161"><a href="#annotated-cell-6-161" aria-hidden="true" tabindex="-1"></a>    __pipeline_wait_prior<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="annotated-cell-6-162"><a href="#annotated-cell-6-162" aria-hidden="true" tabindex="-1"></a>    __syncthreads<span class="op">();</span></span>
<span id="annotated-cell-6-163"><a href="#annotated-cell-6-163" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------------------------------------</span></span>
<span id="annotated-cell-6-164"><a href="#annotated-cell-6-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-165"><a href="#annotated-cell-6-165" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------------- MAIN LOOP -------------</span></span>
<span id="annotated-cell-6-166"><a href="#annotated-cell-6-166" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> K<span class="op">;</span> k <span class="op">+=</span> BLOCK_K<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-167"><a href="#annotated-cell-6-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-168"><a href="#annotated-cell-6-168" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> k_next <span class="op">=</span> k <span class="op">+</span> BLOCK_K<span class="op">;</span></span>
<span id="annotated-cell-6-169"><a href="#annotated-cell-6-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-170"><a href="#annotated-cell-6-170" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 1. LOAD the next tile asynchronously</span></span>
<span id="annotated-cell-6-171"><a href="#annotated-cell-6-171" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k_next <span class="op">&lt;</span> K<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-172"><a href="#annotated-cell-6-172" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Turns 1 into 0 or 0 into 1</span></span>
<span id="annotated-cell-6-173"><a href="#annotated-cell-6-173" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> next_stage <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> stage<span class="op">;</span></span>
<span id="annotated-cell-6-174"><a href="#annotated-cell-6-174" aria-hidden="true" tabindex="-1"></a>            load_tile_async<span class="op">(</span>next_stage<span class="op">,</span> k_next<span class="op">);</span></span>
<span id="annotated-cell-6-175"><a href="#annotated-cell-6-175" aria-hidden="true" tabindex="-1"></a>            __pipeline_commit<span class="op">();</span></span>
<span id="annotated-cell-6-176"><a href="#annotated-cell-6-176" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-6-177"><a href="#annotated-cell-6-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-178"><a href="#annotated-cell-6-178" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 2. MATH: process the current tile. Recall we have a 2 x 2 grid of 16 x 16 subtiles for each warp.</span></span>
<span id="annotated-cell-6-179"><a href="#annotated-cell-6-179" aria-hidden="true" tabindex="-1"></a>        <span class="co">// BLOCK_K = 32, and WMMA accumulates 16x16x16 at a time, so we need to loop k_step 0..1.</span></span>
<span id="annotated-cell-6-180"><a href="#annotated-cell-6-180" aria-hidden="true" tabindex="-1"></a>        <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-6-181"><a href="#annotated-cell-6-181" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k_step <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k_step <span class="op">&lt;</span> BLOCK_K<span class="op">;</span> k_step <span class="op">+=</span> WMMA<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-182"><a href="#annotated-cell-6-182" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="annotated-cell-6-183"><a href="#annotated-cell-6-183" aria-hidden="true" tabindex="-1"></a>            <span class="co">// --- STEP A: Load Fragments into Registers (Pre-Load) ---</span></span>
<span id="annotated-cell-6-184"><a href="#annotated-cell-6-184" aria-hidden="true" tabindex="-1"></a>            <span class="co">// A Warp computes a 32x32 output tile.</span></span>
<span id="annotated-cell-6-185"><a href="#annotated-cell-6-185" aria-hidden="true" tabindex="-1"></a>            <span class="co">// This requires 32 rows of A (2 fragments) and 32 cols of B (2 fragments).</span></span>
<span id="annotated-cell-6-186"><a href="#annotated-cell-6-186" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="annotated-cell-6-187"><a href="#annotated-cell-6-187" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Load the 2 fragments of Matrix A needed for this warp</span></span>
<span id="annotated-cell-6-188"><a href="#annotated-cell-6-188" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-6-189"><a href="#annotated-cell-6-189" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-190"><a href="#annotated-cell-6-190" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> smem_row <span class="op">=</span> warp_row <span class="op">+</span> <span class="op">(</span>i <span class="op">*</span> <span class="dv">16</span><span class="op">);</span></span>
<span id="annotated-cell-6-191"><a href="#annotated-cell-6-191" aria-hidden="true" tabindex="-1"></a>                half<span class="op">*</span> tile_ptr_A <span class="op">=</span> <span class="op">&amp;</span>sA<span class="op">[</span>stage<span class="op">][</span>smem_row <span class="op">*</span> <span class="op">(</span>BLOCK_K <span class="op">+</span> SMEM_PAD<span class="op">)</span> <span class="op">+</span> k_step<span class="op">];</span></span>
<span id="annotated-cell-6-192"><a href="#annotated-cell-6-192" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="annotated-cell-6-193"><a href="#annotated-cell-6-193" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Load into specific index [i]</span></span>
<span id="annotated-cell-6-194"><a href="#annotated-cell-6-194" aria-hidden="true" tabindex="-1"></a>                wmma<span class="op">::</span>load_matrix_sync<span class="op">(</span>a_frag<span class="op">[</span>i<span class="op">],</span> tile_ptr_A<span class="op">,</span> BLOCK_K <span class="op">+</span> SMEM_PAD<span class="op">);</span></span>
<span id="annotated-cell-6-195"><a href="#annotated-cell-6-195" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="annotated-cell-6-196"><a href="#annotated-cell-6-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-197"><a href="#annotated-cell-6-197" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Load the 2 fragments of Matrix B needed for this warp</span></span>
<span id="annotated-cell-6-198"><a href="#annotated-cell-6-198" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-6-199"><a href="#annotated-cell-6-199" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-200"><a href="#annotated-cell-6-200" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> smem_col <span class="op">=</span> warp_col <span class="op">+</span> <span class="op">(</span>j <span class="op">*</span> <span class="dv">16</span><span class="op">);</span></span>
<span id="annotated-cell-6-201"><a href="#annotated-cell-6-201" aria-hidden="true" tabindex="-1"></a>                half<span class="op">*</span> tile_ptr_B <span class="op">=</span> <span class="op">&amp;</span>sB<span class="op">[</span>stage<span class="op">][</span>k_step <span class="op">*</span> <span class="op">(</span>BLOCK_N <span class="op">+</span> SMEM_PAD<span class="op">)</span> <span class="op">+</span> smem_col<span class="op">];</span></span>
<span id="annotated-cell-6-202"><a href="#annotated-cell-6-202" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="annotated-cell-6-203"><a href="#annotated-cell-6-203" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Load into specific index [j]</span></span>
<span id="annotated-cell-6-204"><a href="#annotated-cell-6-204" aria-hidden="true" tabindex="-1"></a>                wmma<span class="op">::</span>load_matrix_sync<span class="op">(</span>b_frag<span class="op">[</span>j<span class="op">],</span> tile_ptr_B<span class="op">,</span> BLOCK_N <span class="op">+</span> SMEM_PAD<span class="op">);</span></span>
<span id="annotated-cell-6-205"><a href="#annotated-cell-6-205" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="annotated-cell-6-206"><a href="#annotated-cell-6-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-207"><a href="#annotated-cell-6-207" aria-hidden="true" tabindex="-1"></a>            <span class="co">// --- STEP B: Compute (Reuse Registers) ---</span></span>
<span id="annotated-cell-6-208"><a href="#annotated-cell-6-208" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-6-209"><a href="#annotated-cell-6-209" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-210"><a href="#annotated-cell-6-210" aria-hidden="true" tabindex="-1"></a>                <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-6-211"><a href="#annotated-cell-6-211" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-212"><a href="#annotated-cell-6-212" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// Reuse a_frag[i] and b_frag[j] multiple times</span></span>
<span id="annotated-cell-6-213"><a href="#annotated-cell-6-213" aria-hidden="true" tabindex="-1"></a>                    wmma<span class="op">::</span>mma_sync<span class="op">(</span>accum_frag<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> a_frag<span class="op">[</span>i<span class="op">],</span> b_frag<span class="op">[</span>j<span class="op">],</span> accum_frag<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="annotated-cell-6-214"><a href="#annotated-cell-6-214" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="annotated-cell-6-215"><a href="#annotated-cell-6-215" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="annotated-cell-6-216"><a href="#annotated-cell-6-216" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-6-217"><a href="#annotated-cell-6-217" aria-hidden="true" tabindex="-1"></a>       </span>
<span id="annotated-cell-6-218"><a href="#annotated-cell-6-218" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-219"><a href="#annotated-cell-6-219" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 3. WAIT for next tile</span></span>
<span id="annotated-cell-6-220"><a href="#annotated-cell-6-220" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">+</span> BLOCK_K <span class="op">&lt;</span> K<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-221"><a href="#annotated-cell-6-221" aria-hidden="true" tabindex="-1"></a>            __pipeline_wait_prior<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="annotated-cell-6-222"><a href="#annotated-cell-6-222" aria-hidden="true" tabindex="-1"></a>            __syncthreads<span class="op">();</span></span>
<span id="annotated-cell-6-223"><a href="#annotated-cell-6-223" aria-hidden="true" tabindex="-1"></a>            stage <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> stage<span class="op">;</span></span>
<span id="annotated-cell-6-224"><a href="#annotated-cell-6-224" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-6-225"><a href="#annotated-cell-6-225" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-6-226"><a href="#annotated-cell-6-226" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------------------------------------</span></span>
<span id="annotated-cell-6-227"><a href="#annotated-cell-6-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-228"><a href="#annotated-cell-6-228" aria-hidden="true" tabindex="-1"></a>    __syncthreads<span class="op">();</span> <span class="co">// Since the syncthreads above won't execute on the last iteration</span></span>
<span id="annotated-cell-6-229"><a href="#annotated-cell-6-229" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="annotated-cell-6-230"><a href="#annotated-cell-6-230" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ------- EPILOGUE: Store C ----------</span></span>
<span id="annotated-cell-6-231"><a href="#annotated-cell-6-231" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We need a Shared Memory buffer for the floats from the Accumulators.</span></span>
<span id="annotated-cell-6-232"><a href="#annotated-cell-6-232" aria-hidden="true" tabindex="-1"></a>    __shared__ <span class="dt">float</span> sC<span class="op">[</span>BLOCK_M <span class="op">*</span> BLOCK_N<span class="op">];</span></span>
<span id="annotated-cell-6-233"><a href="#annotated-cell-6-233" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-234"><a href="#annotated-cell-6-234" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 1. Store Accumulators (Registers) -&gt; Shared Memory (Float)</span></span>
<span id="annotated-cell-6-235"><a href="#annotated-cell-6-235" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Each warp holds a 32x32 tile distributed across 2x2 fragments (16x16 each).</span></span>
<span id="annotated-cell-6-236"><a href="#annotated-cell-6-236" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-6-237"><a href="#annotated-cell-6-237" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-238"><a href="#annotated-cell-6-238" aria-hidden="true" tabindex="-1"></a>        <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-6-239"><a href="#annotated-cell-6-239" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-240"><a href="#annotated-cell-6-240" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Calculate where this 16x16 fragment belongs in the 64x64 block</span></span>
<span id="annotated-cell-6-241"><a href="#annotated-cell-6-241" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> row_offset <span class="op">=</span> warp_row <span class="op">+</span> <span class="op">(</span>i <span class="op">*</span> <span class="dv">16</span><span class="op">);</span></span>
<span id="annotated-cell-6-242"><a href="#annotated-cell-6-242" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> col_offset <span class="op">=</span> warp_col <span class="op">+</span> <span class="op">(</span>j <span class="op">*</span> <span class="dv">16</span><span class="op">);</span></span>
<span id="annotated-cell-6-243"><a href="#annotated-cell-6-243" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="annotated-cell-6-244"><a href="#annotated-cell-6-244" aria-hidden="true" tabindex="-1"></a>            <span class="dt">float</span><span class="op">*</span> smem_ptr <span class="op">=</span> sC <span class="op">+</span> row_offset <span class="op">*</span> BLOCK_N <span class="op">+</span> col_offset<span class="op">;</span></span>
<span id="annotated-cell-6-245"><a href="#annotated-cell-6-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-246"><a href="#annotated-cell-6-246" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Store fragment to shared memory (Stride is BLOCK_N)</span></span>
<span id="annotated-cell-6-247"><a href="#annotated-cell-6-247" aria-hidden="true" tabindex="-1"></a>            wmma<span class="op">::</span>store_matrix_sync<span class="op">(</span>smem_ptr<span class="op">,</span> accum_frag<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> BLOCK_N<span class="op">,</span> wmma<span class="op">::</span>mem_row_major<span class="op">);</span></span>
<span id="annotated-cell-6-248"><a href="#annotated-cell-6-248" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-6-249"><a href="#annotated-cell-6-249" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-6-250"><a href="#annotated-cell-6-250" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-251"><a href="#annotated-cell-6-251" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Wait for all warps to finish writing to sC</span></span>
<span id="annotated-cell-6-252"><a href="#annotated-cell-6-252" aria-hidden="true" tabindex="-1"></a>    __syncthreads<span class="op">();</span></span>
<span id="annotated-cell-6-253"><a href="#annotated-cell-6-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-254"><a href="#annotated-cell-6-254" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 2. Write Shared Memory (Float) -&gt; Global Memory (Half)</span></span>
<span id="annotated-cell-6-255"><a href="#annotated-cell-6-255" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Total Elements: 64 * 64 = 4096.</span></span>
<span id="annotated-cell-6-256"><a href="#annotated-cell-6-256" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Threads: 128.</span></span>
<span id="annotated-cell-6-257"><a href="#annotated-cell-6-257" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Elements per thread: 32.</span></span>
<span id="annotated-cell-6-258"><a href="#annotated-cell-6-258" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Vectors per thread: 32 / 8 = 4 vectors (int4).</span></span>
<span id="annotated-cell-6-259"><a href="#annotated-cell-6-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-260"><a href="#annotated-cell-6-260" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-6-261"><a href="#annotated-cell-6-261" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> v <span class="op">&lt;</span> <span class="dv">4</span><span class="op">;</span> v<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-262"><a href="#annotated-cell-6-262" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Calculate the linear index for this vector of 8 elements</span></span>
<span id="annotated-cell-6-263"><a href="#annotated-cell-6-263" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Stride by THREAD_COUNT to ensure coalescing (Thread 0 takes 0..7, Thread 1 takes 8..15)</span></span>
<span id="annotated-cell-6-264"><a href="#annotated-cell-6-264" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> vec_idx <span class="op">=</span> tid <span class="op">+</span> v <span class="op">*</span> THREAD_COUNT<span class="op">;</span> </span>
<span id="annotated-cell-6-265"><a href="#annotated-cell-6-265" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="annotated-cell-6-266"><a href="#annotated-cell-6-266" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> base_idx <span class="op">=</span> vec_idx <span class="op">*</span> <span class="dv">8</span><span class="op">;</span> <span class="co">// The starting element index</span></span>
<span id="annotated-cell-6-267"><a href="#annotated-cell-6-267" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> row <span class="op">=</span> base_idx <span class="op">/</span> BLOCK_N<span class="op">;</span></span>
<span id="annotated-cell-6-268"><a href="#annotated-cell-6-268" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> col <span class="op">=</span> base_idx <span class="op">%</span> BLOCK_N<span class="op">;</span></span>
<span id="annotated-cell-6-269"><a href="#annotated-cell-6-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-270"><a href="#annotated-cell-6-270" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> global_row <span class="op">=</span> block_row_start <span class="op">+</span> row<span class="op">;</span></span>
<span id="annotated-cell-6-271"><a href="#annotated-cell-6-271" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> global_col <span class="op">=</span> block_col_start <span class="op">+</span> col<span class="op">;</span></span>
<span id="annotated-cell-6-272"><a href="#annotated-cell-6-272" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-273"><a href="#annotated-cell-6-273" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Boundary Check (Safe for arbitrary M/N)</span></span>
<span id="annotated-cell-6-274"><a href="#annotated-cell-6-274" aria-hidden="true" tabindex="-1"></a>        <span class="co">// We check if the whole vector of 8 fits</span></span>
<span id="annotated-cell-6-275"><a href="#annotated-cell-6-275" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>global_row <span class="op">&lt;</span> M <span class="op">&amp;&amp;</span> global_col <span class="op">+</span> <span class="dv">7</span> <span class="op">&lt;</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-276"><a href="#annotated-cell-6-276" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="annotated-cell-6-277"><a href="#annotated-cell-6-277" aria-hidden="true" tabindex="-1"></a>            half out_buffer<span class="op">[</span><span class="dv">8</span><span class="op">];</span> <span class="co">// Register buffer for formatting</span></span>
<span id="annotated-cell-6-278"><a href="#annotated-cell-6-278" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-279"><a href="#annotated-cell-6-279" aria-hidden="true" tabindex="-1"></a>            <span class="co">// OPTIONAL: Beta Handling (Load old C)</span></span>
<span id="annotated-cell-6-280"><a href="#annotated-cell-6-280" aria-hidden="true" tabindex="-1"></a>            <span class="co">// If beta is non-zero, we must load the existing values from Global Memory first</span></span>
<span id="annotated-cell-6-281"><a href="#annotated-cell-6-281" aria-hidden="true" tabindex="-1"></a>            half old_c<span class="op">[</span><span class="dv">8</span><span class="op">];</span> </span>
<span id="annotated-cell-6-282"><a href="#annotated-cell-6-282" aria-hidden="true" tabindex="-1"></a>            <span class="dt">bool</span> use_beta <span class="op">=</span> <span class="op">(</span>beta <span class="op">!=</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">);</span></span>
<span id="annotated-cell-6-283"><a href="#annotated-cell-6-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-284"><a href="#annotated-cell-6-284" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>use_beta<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-285"><a href="#annotated-cell-6-285" aria-hidden="true" tabindex="-1"></a>                 <span class="co">// Vectorized Load of old C</span></span>
<span id="annotated-cell-6-286"><a href="#annotated-cell-6-286" aria-hidden="true" tabindex="-1"></a>                <span class="op">*(</span>int4<span class="op">*)</span>old_c <span class="op">=</span> <span class="op">*(</span>int4<span class="op">*)&amp;</span>C<span class="op">[</span>global_row <span class="op">*</span> N <span class="op">+</span> global_col<span class="op">];</span></span>
<span id="annotated-cell-6-287"><a href="#annotated-cell-6-287" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="annotated-cell-6-288"><a href="#annotated-cell-6-288" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-289"><a href="#annotated-cell-6-289" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Compute scaling and conversion</span></span>
<span id="annotated-cell-6-290"><a href="#annotated-cell-6-290" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#pragma unroll</span></span>
<span id="annotated-cell-6-291"><a href="#annotated-cell-6-291" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> x <span class="op">&lt;</span> <span class="dv">8</span><span class="op">;</span> x<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-292"><a href="#annotated-cell-6-292" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Read float from Shared</span></span>
<span id="annotated-cell-6-293"><a href="#annotated-cell-6-293" aria-hidden="true" tabindex="-1"></a>                <span class="dt">float</span> val <span class="op">=</span> sC<span class="op">[</span>base_idx <span class="op">+</span> x<span class="op">];</span> </span>
<span id="annotated-cell-6-294"><a href="#annotated-cell-6-294" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="annotated-cell-6-295"><a href="#annotated-cell-6-295" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Apply Alpha</span></span>
<span id="annotated-cell-6-296"><a href="#annotated-cell-6-296" aria-hidden="true" tabindex="-1"></a>                val <span class="op">*=</span> alpha<span class="op">;</span></span>
<span id="annotated-cell-6-297"><a href="#annotated-cell-6-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-298"><a href="#annotated-cell-6-298" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Apply Beta</span></span>
<span id="annotated-cell-6-299"><a href="#annotated-cell-6-299" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>use_beta<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-300"><a href="#annotated-cell-6-300" aria-hidden="true" tabindex="-1"></a>                    val <span class="op">+=</span> beta <span class="op">*</span> __half2float<span class="op">(</span>old_c<span class="op">[</span>x<span class="op">]);</span></span>
<span id="annotated-cell-6-301"><a href="#annotated-cell-6-301" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="annotated-cell-6-302"><a href="#annotated-cell-6-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-303"><a href="#annotated-cell-6-303" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Convert to Half</span></span>
<span id="annotated-cell-6-304"><a href="#annotated-cell-6-304" aria-hidden="true" tabindex="-1"></a>                out_buffer<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> __float2half<span class="op">(</span>val<span class="op">);</span></span>
<span id="annotated-cell-6-305"><a href="#annotated-cell-6-305" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="annotated-cell-6-306"><a href="#annotated-cell-6-306" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-307"><a href="#annotated-cell-6-307" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Vectorized Store to Global Memory</span></span>
<span id="annotated-cell-6-308"><a href="#annotated-cell-6-308" aria-hidden="true" tabindex="-1"></a>            <span class="op">*(</span>int4<span class="op">*)&amp;</span>C<span class="op">[</span>global_row <span class="op">*</span> N <span class="op">+</span> global_col<span class="op">]</span> <span class="op">=</span> <span class="op">*(</span>int4<span class="op">*)</span>out_buffer<span class="op">;</span></span>
<span id="annotated-cell-6-309"><a href="#annotated-cell-6-309" aria-hidden="true" tabindex="-1"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-6" data-target-annotation="3">3</button><span id="annotated-cell-6-310" class="code-annotation-target"><a href="#annotated-cell-6-310" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>global_row <span class="op">&lt;</span> M<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-311"><a href="#annotated-cell-6-311" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Edge Case: Partial vector write (at the edge of the matrix)</span></span>
<span id="annotated-cell-6-312"><a href="#annotated-cell-6-312" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> x <span class="op">&lt;</span> <span class="dv">8</span><span class="op">;</span> x<span class="op">++)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-313"><a href="#annotated-cell-6-313" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>global_col <span class="op">+</span> x <span class="op">&lt;</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-314"><a href="#annotated-cell-6-314" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">float</span> val <span class="op">=</span> alpha <span class="op">*</span> sC<span class="op">[</span>base_idx <span class="op">+</span> x<span class="op">];</span></span>
<span id="annotated-cell-6-315"><a href="#annotated-cell-6-315" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="op">(</span>beta <span class="op">!=</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-316"><a href="#annotated-cell-6-316" aria-hidden="true" tabindex="-1"></a>                        val <span class="op">+=</span> beta <span class="op">*</span> __half2float<span class="op">(</span>C<span class="op">[</span>global_row <span class="op">*</span> N <span class="op">+</span> global_col <span class="op">+</span> x<span class="op">]);</span></span>
<span id="annotated-cell-6-317"><a href="#annotated-cell-6-317" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span></span>
<span id="annotated-cell-6-318"><a href="#annotated-cell-6-318" aria-hidden="true" tabindex="-1"></a>                    C<span class="op">[</span>global_row <span class="op">*</span> N <span class="op">+</span> global_col <span class="op">+</span> x<span class="op">]</span> <span class="op">=</span> __float2half<span class="op">(</span>val<span class="op">);</span></span>
<span id="annotated-cell-6-319"><a href="#annotated-cell-6-319" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="annotated-cell-6-320"><a href="#annotated-cell-6-320" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="annotated-cell-6-321"><a href="#annotated-cell-6-321" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="annotated-cell-6-322"><a href="#annotated-cell-6-322" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> </span>
<span id="annotated-cell-6-323"><a href="#annotated-cell-6-323" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="annotated-cell-6-324"><a href="#annotated-cell-6-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-325"><a href="#annotated-cell-6-325" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-326"><a href="#annotated-cell-6-326" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> <span class="st">"C"</span> <span class="dt">void</span> solve<span class="op">(</span><span class="at">const</span> half<span class="op">*</span> A<span class="op">,</span> <span class="at">const</span> half<span class="op">*</span> B<span class="op">,</span> half<span class="op">*</span> C<span class="op">,</span> <span class="dt">int</span> M<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> K<span class="op">,</span> <span class="dt">float</span> alpha<span class="op">,</span> <span class="dt">float</span> beta<span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-6-327"><a href="#annotated-cell-6-327" aria-hidden="true" tabindex="-1"></a>    dim3 blockDim<span class="op">(</span>THREAD_COUNT<span class="op">);</span></span>
<span id="annotated-cell-6-328"><a href="#annotated-cell-6-328" aria-hidden="true" tabindex="-1"></a>    dim3 gridDim<span class="op">((</span>N <span class="op">+</span> BLOCK_N <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> BLOCK_N<span class="op">,</span> <span class="op">(</span>M <span class="op">+</span> BLOCK_M <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> BLOCK_M<span class="op">);</span></span>
<span id="annotated-cell-6-329"><a href="#annotated-cell-6-329" aria-hidden="true" tabindex="-1"></a>    gemm_swizzled_all<span class="op">&lt;&lt;&lt;</span>gridDim<span class="op">,</span> blockDim<span class="op">&gt;&gt;&gt;(</span>A<span class="op">,</span> B<span class="op">,</span> C<span class="op">,</span> M<span class="op">,</span> N<span class="op">,</span> K<span class="op">,</span> alpha<span class="op">,</span> beta<span class="op">);</span></span>
<span id="annotated-cell-6-330"><a href="#annotated-cell-6-330" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-6" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-6" data-code-lines="112" data-code-annotation="1"><strong>Valid flag</strong>: We check if we are far enough within bounds to still do a vectorized load, or if we would go beyond the edges of the input matrices. If we’re far enough within bounds, we can issue our <code>pipeline_memcpy_async</code> command as before.</span>
</dd>
<dt data-target-cell="annotated-cell-6" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-6" data-code-lines="127" data-code-annotation="2"><strong>Zero padding</strong>: If we’re too close to the edge of the matrix, we loop element by element, loading from global memory where we’re still in bounds and padding with zeroes wherever we’re not.</span>
</dd>
<dt data-target-cell="annotated-cell-6" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-6" data-code-lines="310" data-code-annotation="3"><strong>Boundary check for writing</strong>: We have the same boundary checks as usual to not write out zeroes or junk to global memory in the epilogue.</span>
</dd>
</dl>
</section>
<section id="arithmetic-intensity-5" class="level3">
<h3 class="anchored" data-anchor-id="arithmetic-intensity-5">Arithmetic Intensity</h3>
<p>We’re not performing more FLOPs or global memory access than the previous kernel. However, we are avoiding the use of the tiled GEMM kernel entirely, which means that in reality, our overall arithmetic intensity for all test cases will be closer to the optimized kernel’s 32 FLOPs/B. We are not funneling any straggler test cases with awkward dimensions to the tiled kernel which only had 8 FLOPs/B.</p>
</section>
<section id="benchmarks-5" class="level3">
<h3 class="anchored" data-anchor-id="benchmarks-5">Benchmarks</h3>
<p>I omit the benchmark table here as the runtimes were the same as the prior kernel on the LeetGPU test suite, plus or minus some run to run variation. This checks out with my understanding that the runtime is given for a particular test case, that was probably already compatible with our WMMA dimension checks in the previous kernel.</p>
</section>
</section>
<section id="final-performance-analysis" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="final-performance-analysis">Final Performance Analysis</h2>
<p>The final graph of kernel versus runtime on each GPU is below.</p>
<div id="cell-fig-gpu-optimization" class="cell" data-message="false" data-execution_count="1">
<div class="cell-output cell-output-display">
<div id="fig-gpu-optimization" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center" data-cap-location="bottom">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-gpu-optimization-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-gpu-optimization-output-1.png" class="quarto-figure quarto-figure-center figure-img" width="655" height="562">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-gpu-optimization-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: GPU Runtime by Kernel Optimization Step
</figcaption>
</figure>
</div>
</div>
</div>
<p>LeetGPU has a leaderboard for each GPU for the GEMM problem, as well as a list of public solutions ordered by runtime. The leaderboard considers both private and public solutions (it is a user preference whether your solutions are public or not - I left mine as public as I greatly benefited from reading others solutions to understand their approaches). On most of the GPUs, I am not in the top 3 on the leaderboard, but on all of them my solution is in the top 5. In particular, for the Blackwell B200, my solution sits at 1st place by a whopping 1 microsecond over the next best solution. Not bad!</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="images/05_leaderboard.png" class="img-fluid figure-img" style="width:90.0%"></p>
<figcaption class="margin-caption">“ShaderShinobi” is my pseudonym. I debated whether to omit the other leaderboard usernames for anonymity, but those usernames already look pretty pseudonymous. Also, I’m hoping if either of those authors see this post, they’ll contact me to nerd out about GPUs.</figcaption>
</figure>
</div>
</section>
<section id="further-optimizations" class="level2">
<h2 class="anchored" data-anchor-id="further-optimizations">Further Optimizations</h2>
<p>I can almost certainly ascertain that the author of the next best solution had a generally superior kernel though, as their solutions are public. In particular, they used Warp Group MMA, a capability introduced in the Hopper generation that is much more efficient than standard WMMA. The cleanest way to use Warp Group MMA is with an external library, which is prohibited by the problem constraints so I considered it out of scope for this problem. Admirably, this author went ahead and called it directly with PTX code. While I assumed this would be very messy, their solution was surprisingly still quite nice to read. The architecture of Hopper and Blackwell GPUs is quite different and more optimized than previous generations for GEMM operations. In a future post, I will explore Warp Group MMA, the CuTe library, and various optimizations only available on the current generation of GPUs.</p>
</section>
<section id="additional-reading" class="level2">
<h2 class="anchored" data-anchor-id="additional-reading">Additional Reading</h2>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/rohan-reddy\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
        for (let i=0; i<annoteTargets.length; i++) {
          const annoteTarget = annoteTargets[i];
          const targetCell = annoteTarget.getAttribute("data-target-cell");
          const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
          const contentFn = () => {
            const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
            if (content) {
              const tipContent = content.cloneNode(true);
              tipContent.classList.add("code-annotation-tip-content");
              return tipContent.outerHTML;
            }
          }
          const config = {
            allowHTML: true,
            content: contentFn,
            onShow: (instance) => {
              selectCodeLines(instance.reference);
              instance.reference.classList.add('code-annotation-active');
              window.tippy.hideAll();
            },
            onHide: (instance) => {
              unselectCodeLines();
              instance.reference.classList.remove('code-annotation-active');
            },
            maxWidth: 300,
            delay: [50, 0],
            duration: [200, 0],
            offset: [5, 10],
            arrow: true,
            appendTo: function(el) {
              return el.parentElement.parentElement.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'quarto',
            placement: 'right',
            popperOptions: {
              modifiers: [
              {
                name: 'flip',
                options: {
                  flipVariations: false, // true by default
                  allowedAutoPlacements: ['right'],
                  fallbackPlacements: ['right', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left'],
                },
              },
              {
                name: 'preventOverflow',
                options: {
                  mainAxis: false,
                  altAxis: false
                }
              }
              ]        
            }      
          };
          window.tippy(annoteTarget, config); 
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© 2026 Rohan Reddy</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>Built with Quarto</p>
</div>
  </div>
</footer>




</body></html>